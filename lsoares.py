# -*- coding: utf-8 -*-
"""LSoares.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aSkMwpNQ2nnxJjDqzj90iAxL6Eh4TS2s

## Recalcular a fase com base no Doppler em um arquivo de tipo rinex 3

# Dependencias
"""

!pip install georinex
!pip install geopandas

from datetime import datetime, timedelta
from math import isnan

import georinex as gr
import geopandas as gpd
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure, show
plt.style.use('ggplot')

"""# Novo algoritmo proposto"""

""" Ajuste das fases de todas as epocas para todos os satélites
Resumo das variáveis:
file_name => o nome do arquivo de entrada
vars      => um dicionário com nomes das variáveis de cada tipo de satélite
first     => é o índice da linha de registro da primeira época
epoch     => é o índice da linha de registro da época sobre análise
h_list    => uma lista com todas as linhas do cabeçalho
version   => a versão do arquivo rinex lido
ftype     => o tipo do arquivo lido
p_line    => garante que nomes de variáveis em mais de uma linha sejam unidas
r_vars    => um dicionario que relaciona os indices das fases de cada tipo
             de satélite com os índices de seus respectivos dopplers
k         => constante aplicada a fase se houver perda de ciclo
stl_m     => um dicionário com memória das fases acumuladas e dopplers
             de satélites observados nas épocas anteriores
prev      => a data da época anterior
curr      => a data da época sobre análise
"""

from datetime import datetime, timedelta
#file_name = "91877_175M_09_58_49_Topcon_editado.22o"
#file_name = "91877_175O_11_42_39_Chokering_editado.22o"
#file_name = "91877_BRA_R_20220561549 editado.22o"
#file_name = 'SMAR00BRA_R_20222381739.22o'
#file_name = "gnss_log_2022_06_24_09_59_48_Topcon_editado.22o"
#file_name = "gnss_log_2022_06_24_11_42_34_Chokering_editado.22o"
#file_name = "91877_BRA_R_20212021315.21o"
#file_name = "91877_210O_Chokering (more) editado.22o"
#file_name = "91877_202N (more).21o"
#file_name = "GEOP056P (more) editado.22o"
#file_name = "gnss_log_2022_02_25_12_48_20_editado.22o"
file_name = "GEOP265N - Huawei P30 PRO (header editado).23o"
#file_name = "GEOP265N - Samsung S20 FE (header editado).23o"
#file_name = "GEOP300O_Samsung.23o"
#file_name = "GEOP300O_Huawei.23o"
#file_name = "GEOP321M_HUAWEI.23o"
#file_name = "GEOP321M_SAMSUNGA04.23o"
#file_name = "GEOP321M (header editado).23o"




DC = 1.5
dc = timedelta(seconds=int(DC), microseconds=int((DC - int(DC))*10**6))

def is_float(n):
  try:
    float(n)
    return True
  except ValueError:
    return False

vars = {}
def make_header(target):
  """ Lê cabeçalho na origem, escreve no destino e decora quais são as variaveis
  """
  with open(file_name, "r") as source:
    first = None
    is_header_line = True
    h_list = []
    for i, line in enumerate(source):                                           # Verificamos se o arquivo atende aos requisitos do script
      if i == 0:
        if not ("RINEX VERSION / TYPE" in line[60:]):
          print("Este não parece ser um arquivo do tipo rinex.")
          exit()
        version, ftype = line.split()[:2]
        if float(version) < 3.0:
          print("Este script requer arquivos da versão 3 ou superior.")
          exit()
        if not "OBSERVATION" in ftype:
          print("Este script lida com dados de observação.")
          exit()
      if is_header_line:
        h_list.append(line)
        if "END OF HEADER" in line[60:]:
          is_header_line = False
      elif line[0] == '>':
        if first is None:
          first = i
          break
      else:
        print("Arquivo rinex parece mal formado (após o cabeçalho deveria existir uma época).")
        exit()
  p_line = None
  for i, line in enumerate(h_list):
    line = line.replace("\n","")
    endl = "\n" if i != 0 else ""
    target.write(endl + line)
    if "SYS / # / OBS TYPES" in line[60:]:                                      # Precisamos de OBS TYPES para garantir a leitura e escrita correta
      var_names = line[:60].split()
      if p_line is None:
        var_key = var_names[0]
        var_len = int(var_names[1])
        if var_len != len(var_names) - 2:
          p_line = var_names[2:]
        else:
          vars[var_key] = var_names[2:]
      else:
        p_line += var_names
        if len(p_line) == var_len:
          vars[var_key] = list(p_line)
          p_line = None
        elif len(p_line) > var_len:
          print("Arquivo rinex parece mal formado (verifique o número de variáveis em OBS TYPES).")
          exit()
  return first

# Criamos o arquivo de saída preenchido com o cabeçalho
with open("output_"+file_name,"w") as target:
  first = make_header(target)

# Precisamos relacionar variáveis de doppler com suas fases
r_vars = {}
for key in vars:
  r_vars[key] = {"fase":[],"doppler":[]}
  for i, var_name in enumerate(vars[key]):
    if var_name[0] == "L":
      r_vars[key]["fase"].append(i)
      if "D"+var_name[1:] in vars[key]:
        r_vars[key]["doppler"].append(vars[key].index("D"+var_name[1:]))
      else:
        r_vars[key]["doppler"].append(-1)                                       # Mapeamos com -1 o caso onde temos o registro de uma fase sem doppler

# Impressão apenas para fins de depuração
# import pprint
# pp = pprint.PrettyPrinter(indent=4)
# pp.pprint(r_vars)

# Ler a primeira época na origem, atualizar fases e gravar no destino
k = 10000000                                                                    # As fases de todos os satélites inicializam no valor constante 10.000.000
epoch = first
prev = datetime(1978,2,22)
stl_m = {}
with open(file_name, "r") as source:
  with open("output_"+file_name, "a") as target:
    for i, line in enumerate(source):
      line = line.replace("\n","")
      if i < first:                                                             # Escapa das linhas de cabeçalho
        pass
      elif i == first:                                                          # Processa a primeira época
        target.write("\n" + line)
        s = line.split()
        n_sat = int(s[8])
        year, month, day, hour, minute = [int(value) for value in s[1:6]]
        second, microsecond = [int(value) for value in s[6].split(".")]
        curr = datetime(year, month, day, hour, minute, second, microsecond//10)
      elif i > first and i <= first + n_sat:                                    # Processa cada satélite da primeira época
        key = line[0]
        sat = line[:3]
        data = line[3:]
        target.write("\n" + sat)
        for j, var_name in enumerate(vars[key]):
          r = r_vars[key]
          if j in r["fase"]:
            d_idx = r["doppler"][r["fase"].index(j)]
            if d_idx != -1:
              doppler = data[d_idx*16:(d_idx+1)*16-2]
              if is_float(doppler):
                target.write("%14.3f  " % (k))
                stl_m[(sat,var_name)] = (k, float(doppler), curr)
                continue
          #target.write(data[j*16:(j+1)*16])
          target.write(data[j*16:(j+1)*16-2] + "  ")                           # Para descartar todos os SLI e LLI use esta linha no lugar da anterior
      else:
        epoch = i
        break

# Ler todas as demais épocas e gravar no destino
cycle_slip = False
with open(file_name, "r") as source:
  with open("output_"+file_name, "a") as target:
    stl = {}
    for i, line in enumerate(source):
      line = line.replace("\n","")
      if i < epoch:
        pass
      elif i == epoch and len(line) > 0 and line[0] == '>':                     # Identifica linhas de inicio de eṕoca
        target.write("\n" + line)
        s = line.split()
        n_sat = int(s[8])
        year, month, day, hour, minute = [int(value) for value in s[1:6]]
        second, microsecond = [int(value) for value in s[6].split(".")]
        curr = datetime(year, month, day, hour, minute, second, microsecond//10)# microsegundo em python tem resolução de 6 dígitos, no rinex são 7
        #cycle_slip = curr - prev >= timedelta(seconds=1, microseconds=500000)
      elif i > epoch and i <= epoch + n_sat:
        key = line[0]
        sat = line[:3]
        data = line[3:]
        target.write("\n" + sat)
        if not key in vars:                                                     # Identifica chaves inválidas
          print(f"Erro ao processar a linha {i+1}. Indicador do tipo de observação inválido.")
          print(line)
          break
        for j, var_name in enumerate(vars[key]):
          r = r_vars[key]
          if j in r["fase"]:
            d_idx = r["doppler"][r["fase"].index(j)]
            if d_idx != -1:
              curr_doppler = data[d_idx*16:(d_idx+1)*16-2]
              if is_float(curr_doppler):
                curr_doppler = float(curr_doppler)
                if (sat,var_name) in stl_m: #and not cycle_slip:
                  prev_fase, prev_doppler, prev = stl_m[(sat,var_name)]
                  cycle_slip = curr - prev >= dc
                  if cycle_slip:                                                # manter hipoteses de reinício
                    target.write("%14.3f  " % (k))
                    stl[(sat,var_name)] = (k, float(curr_doppler), curr)
                  else:                                                         # manter hipoteses de aplicar fórmula
                    curr_fase = prev_fase - (prev_doppler + curr_doppler) / 2
                    target.write("%14.3f  " % (curr_fase))
                    stl[(sat,var_name)] = (curr_fase, float(curr_doppler), curr)
                else:
                  target.write("%14.3f  " % (k))
                  stl[(sat,var_name)] = (k, float(curr_doppler), curr)
                continue
          target.write(data[j*16:(j+1)*16-2] + "  ")
        if i == epoch + n_sat:
          for key in stl_m.keys():
            if not (key in stl):
              if (curr - stl_m[key][2] <= dc):
                stl[key] = stl_m[key]                                           # preservando satélites que foram observados pela última vez num intervalo de tempo estipulado
          stl_m = dict(stl)
          prev = curr
          epoch += n_sat + 1
      else:
        print(f"Processamento terminado após a época {prev}.")
        if line:
          print(f"A última linha de dado é {i+1}:")
          print(line)
        break

"""# análise de diferencas entre os arquivos"""

!head -n 50 "output_91877_BRA_R_20220561549 editado.22o"

!head -n 50 "91877_BRA_R_20220561549 editado.22o"

!diff "91877_BRA_R_20220561549 editado.22o" "output_91877_BRA_R_20220561549 editado.22o"

"""# Backup"""

""" Ajuste das fases de todas as epocas para todos os satélites
Resumo das variáveis:
file_name => o nome do arquivo de entrada
vars      => um dicionário com nomes das variáveis de cada tipo de satélite
first     => é o índice da linha de registro da primeira época
epoch     => é o índice da linha de registro da época sobre análise
h_list    => uma lista com todas as linhas do cabeçalho
version   => a versão do arquivo rinex lido
ftype     => o tipo do arquivo lido
p_line    => garante que nomes de variáveis em mais de uma linha sejam unidas
r_vars    => um dicionario que relaciona os indices das fases de cada tipo
             de satélite com os índices de seus respectivos dopplers
k         => constante aplicada a fase se houver perda de ciclo
stl_m     => um dicionário com memória das fases acumuladas e dopplers
             de satélites observados na época anterior
prev      => a data da época anterior
curr      => a data da época sobre análise
"""

from datetime import datetime, timedelta
#file_name = "91877_175M_09_58_49_Topcon_editado.22o"
#file_name = "91877_175O_11_42_39_Chokering_editado.22o"
#file_name = "91877_BRA_R_20220561549 editado.22o"
#file_name = 'SMAR00BRA_R_20222381739.22o'
#file_name = "gnss_log_2022_06_24_09_59_48_Topcon_editado.22o"
#file_name = "gnss_log_2022_06_24_11_42_34_Chokering_editado.22o"
#file_name = "GEOP265N - Huawei P30 PRO (header editado).23o"
#file_name = "GEOP265N - Samsung S20 FE (header editado).23o"
#file_name = "GEOP300O_Samsung.23o"
#file_name = "GEOP321M_HUAWEI.23o"
#file_name = "GEOP300O_Huawei.23o"
#file_name = "GEOP321M_SAMSUNGA04.23o"
#file_name = "GEOP321M (header editado).23o"

def is_float(n):
  try:
    float(n)
    return True
  except ValueError:
    return False

vars = {}
def make_header(target):
  """ Lê cabeçalho na origem, escreve no destino e decora quais são as variaveis
  """
  with open(file_name, "r") as source:
    first = None
    is_header_line = True
    h_list = []
    for i, line in enumerate(source):                                           # Verificamos se o arquivo atende aos requisitos do script
      if i == 0:
        if not ("RINEX VERSION / TYPE" in line[60:]):
          print("Este não parece ser um arquivo do tipo rinex.")
          exit()
        version, ftype = line.split()[:2]
        if float(version) < 3.0:
          print("Este script requer arquivos da versão 3 ou superior.")
          exit()
        if not "OBSERVATION" in ftype:
          print("Este script lida com dados de observação.")
          exit()
      if is_header_line:
        h_list.append(line)
        if "END OF HEADER" in line[60:]:
          is_header_line = False
      elif line[0] == '>':
        if first is None:
          first = i
          break
      else:
        print("Arquivo rinex parece mal formado (após o cabeçalho deveria existir uma época).")
        exit()
  p_line = None
  for i, line in enumerate(h_list):
    line = line.replace("\n","")
    endl = "\n" if i != 0 else ""
    target.write(endl + line)
    if "SYS / # / OBS TYPES" in line[60:]:                                      # Precisamos de OBS TYPES para garantir a leitura e escrita correta
      var_names = line[:60].split()
      if p_line is None:
        var_key = var_names[0]
        var_len = int(var_names[1])
        if var_len != len(var_names) - 2:
          p_line = var_names[2:]
        else:
          vars[var_key] = var_names[2:]
      else:
        p_line += var_names
        if len(p_line) == var_len:
          vars[var_key] = list(p_line)
          p_line = None
        elif len(p_line) > var_len:
          print("Arquivo rinex parece mal formado (verifique o número de variáveis em OBS TYPES).")
          exit()
  return first

# Criamos o arquivo de saída preenchido com o cabeçalho
with open("output_"+file_name,"w") as target:
  first = make_header(target)

# Precisamos relacionar variáveis de doppler com suas fases
r_vars = {}
for key in vars:
  r_vars[key] = {"fase":[],"doppler":[]}
  for i, var_name in enumerate(vars[key]):
    if var_name[0] == "L":
      r_vars[key]["fase"].append(i)
      if "D"+var_name[1:] in vars[key]:
        r_vars[key]["doppler"].append(vars[key].index("D"+var_name[1:]))
      else:
        r_vars[key]["doppler"].append(-1)                                       # Mapeamos com -1 o caso onde temos o registro de uma fase sem doppler

# Impressão apenas para fins de depuração
# import pprint
# pp = pprint.PrettyPrinter(indent=4)
# pp.pprint(r_vars)

# Ler a primeira época na origem, atualizar fases e gravar no destino
k = 10000000                                                                    # As fases de todos os satélites inicializam no valor constante 10.000.000
epoch = first
prev = datetime(1978,2,22)
stl_m = {}
with open(file_name, "r") as source:
  with open("output_"+file_name, "a") as target:
    for i, line in enumerate(source):
      line = line.replace("\n","")
      if i < first:
        pass
      elif i == first:
        target.write("\n" + line)
        s = line.split()
        n_sat = int(s[8])
        year, month, day, hour, minute = [int(value) for value in s[1:6]]
        second, microsecond = [int(value) for value in s[6].split(".")]
        prev = datetime(year, month, day, hour, minute, second, microsecond//10)
      elif i > first and i <= first + n_sat:
        key = line[0]
        sat = line[:3]
        data = line[3:]
        target.write("\n" + sat)
        for j, var_name in enumerate(vars[key]):
          r = r_vars[key]
          if j in r["fase"]:
            d_idx = r["doppler"][r["fase"].index(j)]
            if d_idx != -1:
              doppler = data[d_idx*16:(d_idx+1)*16-2]
              if is_float(doppler):
                target.write("%14.3f  " % (k))
                stl_m[(sat,var_name)] = (k, float(doppler))
                continue
          #target.write(data[j*16:(j+1)*16])
          target.write(data[j*16:(j+1)*16-2] + "  ")                           # Para descartar todos os SLI e LLI use esta linha no lugar da anterior
      else:
        epoch = i
        break

# Ler todas as demais épocas e gravar no destino
cycle_slip = False
with open(file_name, "r") as source:
  with open("output_"+file_name, "a") as target:
    stl = {}
    for i, line in enumerate(source):
      line = line.replace("\n","")
      if i < epoch:
        pass
      elif i == epoch and len(line) > 0 and line[0] == '>':
        target.write("\n" + line)
        s = line.split()
        n_sat = int(s[8])
        year, month, day, hour, minute = [int(value) for value in s[1:6]]
        second, microsecond = [int(value) for value in s[6].split(".")]
        curr = datetime(year, month, day, hour, minute, second, microsecond//10)# microsegundo em python tem resolução de 6 dígitos, no rinex são 7
        cycle_slip = curr - prev >= timedelta(seconds=1, microseconds=500000)
      elif i > epoch and i <= epoch + n_sat:
        key = line[0]
        sat = line[:3]
        data = line[3:]
        target.write("\n" + sat)
        if not key in vars:
          print(f"Erro ao processar a linha {i+1}. Indicador do tipo de observação inválido.")
          print(line)
          break
        for j, var_name in enumerate(vars[key]):
          r = r_vars[key]
          if j in r["fase"]:
            d_idx = r["doppler"][r["fase"].index(j)]
            if d_idx != -1:
              curr_doppler = data[d_idx*16:(d_idx+1)*16-2]
              if is_float(curr_doppler):
                curr_doppler = float(curr_doppler)
                if (sat,var_name) in stl_m and not cycle_slip:
                  prev_fase, prev_doppler = stl_m[(sat,var_name)]
                  curr_fase = prev_fase - (prev_doppler + curr_doppler) / 2
                  target.write("%14.3f  " % (curr_fase))
                  stl[(sat,var_name)] = (curr_fase, float(curr_doppler))
                else:
                  target.write("%14.3f  " % (k))
                  stl[(sat,var_name)] = (k, float(curr_doppler))
                continue
            target.write(data[j*16:(j+1)*16-2] + "  ")
        if i == epoch + n_sat:
          stl_m = dict(stl)
          prev = curr
          epoch += n_sat + 1
      else:
        print(f"Processamento terminado após a época {prev}.")
        if line:
          print(f"A última linha de dado é {i+1}:")
          print(line)
        break

"""# Algoritmo proposto anteriormente"""

with open('91877_202N (more) TPSG3_A1.21o') as f:
  for i,l in enumerate(f):
    if i == 100:
      break
    print(l, end="")

""" Teste da hipotese de ajuste da fase epoca a epoca para todos os satélites
"""

# Arquivo em análise
file_name = 'SMAR00BRA_R_20222381739.22o'
#file_name = '91877_202N (more) TPSG3_A1.21o'

# Função para escrita de cabeçalho atualizado
vars = {}
def makeHeader(file):
  input = open(file_name, "r")
  first, second = None, None
  header = True
  h_list = []
  for line in input:
    if header:
      h_list.append(line)
    if "END OF HEADER" in line[60:]:
      header = False
    if line[0] == '>':
      if first is None:
        first = line
      else:
        second = line
        break
  s = second.split()
  t = (int(s[1]), int(s[2]), int(s[3]), int(s[4]), int(s[5]), float(s[6]))
  for line in h_list:
    if "TIME OF FIRST OBS" in line[60:]:
      linedate = "%6d%6d%6d%6d%6d%13.7f%8s         TIME OF FIRST OBS\n"
      system = line[43:51]
      linedate %= (t[0], t[1], t[2], t[3], t[4], t[5], system)
      file.write(linedate)
    elif "SYS / # / OBS TYPES" in line[60:]:                                    # Precisamos de OBS TYPES
      file.write(line)
      words = line[:60].split()
      var_name = words[0]
      var_size = int(words[1])
      if var_size != len(words) - 2:
        print("Observation type has an interpretation error:")
        print(line)
      vars[var_name] = words[2:]
    else:
      file.write(line)

# Função de análise para cada época
sv_l = {}                                                                       # Fase dos satélites analisados
def filter(t0, t2, file):
  dat = gr.load(file_name, tlim=[t0 , t2]) # Temos as épocas t0 e t1
  var = list(dat.data_vars.keys())         # E os nomes de suas variáveis
  diff = 0
  obs = []
  # Para cada satélite na época de análise
  for i, sat in enumerate(dat.sv):
    s_var = vars[dat.sv.data[i][0]]                                             # Recuperamos a lista de variáveis para o satélite em questão
    s_obs = dat.sv.data[i]
    # Para todas as variáveis
    for j in range(len(s_var) // 4):
      c_var, l_var, d_var, i_var = s_var[j*4+0], s_var[j*4+1], s_var[j*4+2], s_var[j*4+3]
      if not ((dat.sv.data[i],l_var) in sv_l):                                  # Ao descobrir um satélite o inicializamos
        sv_l[(dat.sv.data[i],l_var)] = 10000000.0
      # Testamos se houve ausencia de sinal de um dos satélites em época anterior
      if isnan(dat.data_vars[d_var].data[0, i]) and \
        not isnan(dat.data_vars[d_var].data[1, i]):
        sv_l[(dat.sv.data[i],l_var)] = 10000000.0
        s_obs += "%14.3f  %14.3f  %14.3f  %14.3f  " % (dat.data_vars[c_var][1, i],
                                                       sv_l[(dat.sv.data[i],l_var)],
                                                       dat.data_vars[d_var][1, i],
                                                       dat.data_vars[i_var][1, i])
      if not isnan(dat.data_vars[d_var].data[0, i]) and \
        not isnan(dat.data_vars[d_var].data[1, i]):
        sv_l[(dat.sv.data[i],l_var)] += (dat.data_vars[d_var][0, i] + dat.data_vars[d_var][1, i])/2
        s_obs += "%14.3f  %14.3f  %14.3f  %14.3f  " % (dat.data_vars[c_var][1, i],
                                                       sv_l[(dat.sv.data[i],l_var)],
                                                       dat.data_vars[d_var][1, i],
                                                       dat.data_vars[i_var][1, i])
      if not isnan(dat.data_vars[d_var].data[0, i]) and \
        isnan(dat.data_vars[d_var].data[1, i]):
        diff -= 1
      if isnan(dat.data_vars[d_var].data[0, i]) and \
        isnan(dat.data_vars[d_var].data[1, i]):
        s_obs += " " * (16*4)
    if len(s_obs.split()) > 1:
      obs.append(s_obs + "\n")
  dt = str(dat.time.data[1])
  fmt = ">%s %s %s %s %s %s 0 %2d\n"
  epoch = fmt % (dt[0:4],dt[5:7],dt[8:10],dt[11:13],dt[14:16],dt[17:27], len(dat.sv) + diff )
  file.write( epoch )
  for item in obs:
    file.write( item )


# Busca das épocas inicial e final no arquivo
with open(file_name) as f:
    start = None
    end = None
    for line in f:
        if len(line) > 0 and line[0] == '>':
            if start is None:
                start = line
            else:
                end = line

s, e = start.split(), end.split()
start = "%s-%02d-%02dT%02d:%02d:%02d" % (s[1], int(s[2]), int(s[3]), int(s[4]), int(s[5]), float(s[6]))
end   = "%s-%02d-%02dT%02d:%02d:%02d" % (e[1], int(e[2]), int(e[3]), int(e[4]), int(e[5]), float(e[6]))

# Prepara o arquivo de saída
output = open("saida.22o","w")
makeHeader(output)

# Loop de execução época por época
epoch = 0
while start != end:
    epoch += 1
    t0 = datetime.fromisoformat(start)
    t1 = t0 + timedelta(seconds=1)
    t2 = t1 + timedelta(seconds=1)
    next = t2.isoformat()
    filter(start, next, output)
    start = t1.isoformat()
    if epoch == 10:             # Limite do número de iterações na fase de testes
        break

# Fechar o arquivo de saida
output.close()

"""# Investigando erro no filtro"""

dat = gr.load('91877_175M_09_58_49_Topcon_editado.22o', tlim=['2022-06-24T14:14:23','2022-06-24T14:14:25']) # Temos as épocas t0 e t1

len(dat.time)

""" Teste da hipotese de ajuste da fase epoca a epoca para todos os satélites
"""

# Arquivo em análise
#name = 'test.22o'
#name = 'SMAR00BRA_R_20222381739.22o'
name = '91877_175M_09_58_49_Topcon_editado.22o'
#name = '91877_175O_11_42_39_Chokering_editado.22o'
file_name = '{}'.format(name)

# Função para escrita de cabeçalho atualizado
vars = {}
def makeHeader(file):
  input = open(file_name, "r")
  first, second = None, None
  header = True
  h_list = []
  for line in input:
    if header:
      h_list.append(line)
    if "END OF HEADER" in line[60:]:
      header = False
    if line[0] == '>':
      if first is None:
        first = line
      else:
        second = line
        break
  s = second.split()
  t = (int(s[1]), int(s[2]), int(s[3]), int(s[4]), int(s[5]), float(s[6]))
  for line in h_list:
    if "TIME OF FIRST OBS" in line[60:]:
      linedate = "%6d%6d%6d%6d%6d%13.7f%8s         TIME OF FIRST OBS\n"
      system = line[43:51]
      linedate %= (t[0], t[1], t[2], t[3], t[4], t[5], system)
      file.write(linedate)
    elif "SYS / # / OBS TYPES" in line[60:]:                              # Precisamos de OBS TYPES
      file.write(line)
      words = line[:60].split()
      var_name = words[0]
      var_size = int(words[1])
      if var_size != len(words) - 2:
        print("Observation type has an interpretation error:")
        print(line)
      vars[var_name] = words[2:]
    else:
      file.write(line)

# Função de análise para cada época
sv_l = {}                                                                       # Fase dos satélites analisados
def filter(t0, t2, file):
  try:
    dat = gr.load(file_name, tlim=[t0 , t2]) # Temos as épocas t0 e t1
    if len(dat.time) != 2:
      print(t0, t2)
      return False
    var = list(dat.data_vars.keys())         # E os nomes de suas variáveis
    diff = 0
    obs = []
    # Para cada satélite na época de análise
    for i, sat in enumerate(dat.sv):
      s_var = vars[dat.sv.data[i][0]]                                             # Recuperamos a lista de variáveis para o satélite em questão
      s_obs = dat.sv.data[i]
      # Para todas as variáveis
      for j in range(len(s_var) // 4):
        c_var, l_var, d_var, i_var = s_var[j*4+0], s_var[j*4+1], s_var[j*4+2], s_var[j*4+3]
        if not ((dat.sv.data[i],l_var) in sv_l):                                  # Ao descobrir um satélite o inicializamos
          sv_l[(dat.sv.data[i],l_var)] = 10000000.0
        # Testamos se houve ausencia de sinal de um dos satélites em época anterior
        if isnan(dat.data_vars[d_var].data[0, i]) and \
          not isnan(dat.data_vars[d_var].data[1, i]):
          sv_l[(dat.sv.data[i],l_var)] = 10000000.0
          s_obs += "%14.3f  %14.3f  %14.3f  %14.3f  " % (dat.data_vars[c_var][1, i],
                                                         sv_l[(dat.sv.data[i],l_var)],
                                                         dat.data_vars[d_var][1, i],
                                                         dat.data_vars[i_var][1, i])
        if not isnan(dat.data_vars[d_var].data[0, i]) and \
          not isnan(dat.data_vars[d_var].data[1, i]):
          sv_l[(dat.sv.data[i],l_var)] -= (dat.data_vars[d_var][0, i] + dat.data_vars[d_var][1, i])/2
          s_obs += "%14.3f  %14.3f  %14.3f  %14.3f  " % (dat.data_vars[c_var][1, i],
                                                         sv_l[(dat.sv.data[i],l_var)],
                                                         dat.data_vars[d_var][1, i],
                                                         dat.data_vars[i_var][1, i])
        if not isnan(dat.data_vars[d_var].data[0, i]) and \
          isnan(dat.data_vars[d_var].data[1, i]):
          diff -= 1
        if isnan(dat.data_vars[d_var].data[0, i]) and \
          isnan(dat.data_vars[d_var].data[1, i]):
          s_obs += " " * (16*4)
      if len(s_obs.split()) > 1:
        obs.append(s_obs + "\n")
    dt = str(dat.time.data[1])
    fmt = "> %s %s %s %s %s %s 0 %2d\n"
    epoch = fmt % (dt[0:4],dt[5:7],dt[8:10],dt[11:13],dt[14:16],dt[17:27], len(dat.sv) + diff )
    file.write( epoch )
    for item in obs:
      file.write( item )
    return True
  except:
    return False


# Busca das épocas inicial e final no arquivo
with open(file_name) as f:
    start = None
    end = None
    for line in f:
        if len(line) > 0 and line[0] == '>':
            if start is None:
                start = line
            else:
                end = line

s, e = start.split(), end.split()
start = "%s-%02d-%02dT%02d:%02d:%02d" % (s[1], int(s[2]), int(s[3]), int(s[4]), int(s[5]), float(s[6]))
end   = "%s-%02d-%02dT%02d:%02d:%02d" % (e[1], int(e[2]), int(e[3]), int(e[4]), int(e[5]), float(e[6]))

# Prepara o arquivo de saída
output = open("output_{}".format(file_name),"w")
makeHeader(output)

# Loop de execução época por época
epoch = 0
while start != end:
    epoch += 1
    t0 = datetime.fromisoformat(start)
    t1 = t0 + timedelta(seconds=1)
    t2 = t1 + timedelta(seconds=1)
    next = t2.isoformat()
    if not filter(start, next, output):
      pass #break
    start = t1.isoformat()

# Fechar o arquivo de saida
output.close()