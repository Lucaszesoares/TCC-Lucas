# -*- coding: utf-8 -*-
"""LSoares_new_approach_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LLC1pZdJ432W0PjoftFvwBqLV1UHHs5B

# Reconstrução de arquivo Rinex

Baseado nas especificações para arquivos [Rinex 3](https://files.igs.org/pub/data/format/rinex305.pdf), vamos projetar rotinas reutilizáveis que permitam modificar arquivos de observação.

## Uma abordagem procedural

A abordagem anterior por Matheus Belo definia um grande processo de leitura e escrita de complexo entendimento devido a objetividade de seu trabalho. Em suma, cada linha do arquivo de origem era imediatamente processada e gravada no arquivo de destino.  Nossos novos objetivos levam a uma necessidade de flexibilizar o processo dividindo-o em partes substituíveis para testar diferentes hipóteses de solução. Sabemos que para os novos problemas possivelmente teremos de memorizar todo o cabeçalho e algumas épocas antes de iniciar quaisquer gravações no arquivo.

Podemos dividir um arquivo com dados de observações em duas partes principais, cabeçalho e registro de dados, e precisamos definir uma representação para conjuntos de dados importantes para o processamento em cada uma destas partes.

O cabeçalho possui início e fim bem determinados e nele há dados essenciais como tempo de início da observação e tipos de observação contidos entre os registros.

A parte de registros de dados está estruturada em épocas. Cada época registra um número de observações de satélites variável. Por sua vez as observações de satélites são identificadas por tipo e registram variáveis conforme a definição dada no cabeçalho.

O formato Rinex normatiza o espaço reservado para cada variavel e nomes que são esperados.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile RinexRemake.py
# """
# Definição do módulo RinexRemake. Suas rotinas possibilitam a montagem de um
# processo para edição e remotangem de arquivos Rinex, quando não há registro
# adequado da fase portadora pelo receptor, por exemplo. Outra utilidade para
# remontagem inclui a possibilidade de ajuste no tempo das épocas registradas.
# """
# 
# from datetime import datetime, timedelta
# import os
# 
# def updateCarrierPhase(epoach, obsMemory, const, threshold, codes, types,
#                        updateMemory = True, log = open("RinexRemake.log","a")):
#   epoachTime = getEpoachTime(epoach, log)
#   for i,register in enumerate(epoach[1:]):
#     if (not register[0] in satelliteSystemIdentifier()) or (not register[1:3].isnumeric()):
#       continue
#     restart = False
#     if threshold.total_seconds() < getObsRegisterDelta(register, epoachTime, obsMemory, log):
#       restart = True
#     # Para cada uma dos códigos presentes na observacão
#     for var in codes[register[0]]:
#       # Se doppler e a fase estão mapeados para armazenamento
#       if codes[register[0]][var]['D'] != -1 and codes[register[0]][var]['L'] != -1:
#         doppler = getObsData(register, 'D'+var, codes, log)
#         # E o doppler armazenado é não nulo
#         if is_float(doppler['src']):
#           phase = getObsData(register, 'L'+var, codes, log)
#           LLI = phase['lli']
#           SSI = phase['ssi']
#           if restart:
#             curr_phase = const
#           else:
#             curr_doppler = doppler['value']
#             prev_phase = obsMemory[register[:3]]['type'][var]['L']['value']
#             prev_doppler = obsMemory[register[:3]]['type'][var]['D']['value']
#             curr_phase = prev_phase - (prev_doppler + curr_doppler) / 2
#           register = setObsData(register, curr_phase, LLI, SSI, 'L'+var, codes, log)
#     if updateMemory:
#       for var in codes[register[0]]:
#         # Após atualizar o registro memorizamos o novo estado
#         for index in codes[register[0]][var]:
#           if index+var in types[register[0]]:
#             data = getObsData(register, index+var, codes, log)
#             updateObsRegisterMemory(register[:3], index+var, data, epoachTime, obsMemory, log)
#     epoach[i+1] = register
#   return epoach
# 
# def reduceEpoachTime(epoach, obsMemory, const, threshold, codes, types,
#                      updateMemory = True, log = open("RinexRemake.log","a")):
#   epoachTime = getEpoachTime(epoach, log)
#   fraction = epoachTime.microsecond
#   reducedTime = epoachTime - timedelta(microseconds=fraction)
#   out_epoach = setEpoachTime(epoach, reducedTime, log)[:1]
#   dat_epoach = out_epoach[0].split()
#   fraction *= 10**-6
#   for register in epoach[1:]:
#     # Se o registro não é processável copiamos ele e seguimos em frente
#     if (not register[0] in satelliteSystemIdentifier()) or (not register[1:3].isnumeric()):
#       out_epoach += [register]
#       continue
#     # Caso o intervalo entre este registro e a última vez que o mesmo satélite foi
#     # observado supere o limiar, vamos omití-lo nesta época, mas memorizar sua obs.
#     delta = getObsRegisterDelta(register, epoachTime, obsMemory, log)
#     if threshold.total_seconds() < delta:
#       out_epoach[0] = " ".join(dat_epoach[:8] + [str(int(dat_epoach[8])-1)]) + "\n"
#       dat_epoach = out_epoach[0].split()
#       for var in codes[register[0]]:
#         for index in codes[register[0]][var]:
#           if index+var in types[register[0]]:
#             data = getObsData(register, index+var, codes, log)
#             updateObsRegisterMemory(register[:3], index+var, data, epoachTime, obsMemory, log)
#       continue
#     # Caso contrário, para cada uma dos códigos presentes na observacão
#     for var in codes[register[0]]:
#       # Se doppler, a fase e a pseudo distância estão mapeados para armazenamento
#       if codes[register[0]][var]['D'] != -1 and \
#          codes[register[0]][var]['L'] != -1 and \
#          codes[register[0]][var]['C'] != -1:
#         doppler = getObsData(register, 'D'+var, codes, log)
#         # E o doppler armazenado é não nulo
#         if is_float(doppler['src']):
#           # Recuperamos o doppler atual e anterior
#           curr_doppler = doppler['value']
#           prev_doppler = obsMemory[register[:3]]['type'][var]['D']['value']
#           # Temos que recuperar a frequência para o código do satélite
#           freq = codes[register[0]][var]['F']
#           # A frequência, pode ser dada por uma função, nestes casos chamamos a mesma
#           freq = freq if type(freq) == float else freq(glonass_k[register[:3]])
#           # De posse na frequência, deduz-se o comprimento de onda do código
#           w_len = 1/freq
#           # Ajustamos a fase
#           phase = getObsData(register, 'L'+var, codes, log)
#           curr_phase = phase['value']
#           LLI = phase['lli']
#           SSI = phase['ssi']
#           curr_phase += fraction*(prev_doppler + curr_doppler) / 2
#           register = setObsData(register, curr_phase, LLI, SSI, 'L'+var, codes, log)
#           # E ajustamos a pseudo-distância
#           p_range = getObsData(register, 'C'+var, codes, log)
#           curr_p_range = p_range['value']
#           LLI = p_range['lli']
#           SSI = p_range['ssi']
#           curr_p_range += w_len*fraction*(prev_doppler + curr_doppler) / 2
#           register = setObsData(register, curr_p_range, LLI, SSI, 'C'+var, codes, log)
#     if updateMemory:
#       for var in codes[register[0]]:
#         # Após atualizar o registro memorizamos o novo estado
#         for index in codes[register[0]][var]:
#           if index+var in types[register[0]]:
#             data = getObsData(register, index+var, codes, log)
#             updateObsRegisterMemory(register[:3], index+var, data, epoachTime, obsMemory, log)
#     out_epoach += [register]
#   return out_epoach
# 
# def combineEpoachTime(epoach, obsMemory, const, threshold, codes, types,
#                       updateMemory = True, log = open("RinexRemake.log","a")):
#   epoachTime = getEpoachTime(epoach, log)
#   fraction = epoachTime.microsecond
#   reducedTime = epoachTime - timedelta(microseconds=fraction)
#   out_epoach = setEpoachTime(epoach, reducedTime, log)[:1]
#   dat_epoach = out_epoach[0].split()
#   fraction *= 10**-6
#   for register in epoach[1:]:
#     # Se o registro não é processável copiamos ele e seguimos em frente
#     if (not register[0] in satelliteSystemIdentifier()) or (not register[1:3].isnumeric()):
#       out_epoach += [register]
#       continue
#     # Caso o intervalo entre este registro e a última vez que o mesmo satélite foi
#     # observado supere o limiar, vamos omití-lo nesta época, mas memorizar sua obs.
#     delta = getObsRegisterDelta(register, epoachTime, obsMemory, log)
#     if threshold.total_seconds() < delta:
#       out_epoach[0] = " ".join(dat_epoach[:8] + [str(int(dat_epoach[8])-1)]) + "\n"
#       dat_epoach = out_epoach[0].split()
#       for var in codes[register[0]]:
#         for index in codes[register[0]][var]:
#           if index+var in types[register[0]]:
#             data = getObsData(register, index+var, codes, log)
#             updateObsRegisterMemory(register[:3], index+var, data, epoachTime, obsMemory, log)
#       continue
#     in_register = str(register)
#     # Caso contrário, para cada uma dos códigos presentes na observacão
#     for var in codes[in_register[0]]:
#       # Se doppler, a fase e a pseudo distância estão mapeados para armazenamento
#       if codes[register[0]][var]['D'] != -1 and \
#          codes[register[0]][var]['L'] != -1 and \
#          codes[register[0]][var]['C'] != -1:
#         doppler = getObsData(register, 'D'+var, codes, log)
#         # E o doppler armazenado é não nulo
#         if is_float(doppler['src']):
#           # Determinamos o grau de mistura dos valores com base no intervalo
#           alpha = fraction/delta
#           # Ajustamos a fase
#           phase = getObsData(register, 'L'+var, codes, log)
#           curr_phase = phase['value']
#           LLI = phase['lli']
#           SSI = phase['ssi']
#           prev_phase = obsMemory[register[:3]]['type'][var]['L']['value']
#           curr_phase = (alpha*curr_phase + (1-alpha)*prev_phase) / delta
#           register = setObsData(register, curr_phase, LLI, SSI, 'L'+var, codes, log)
#           # E ajustamos a pseudo-distância
#           p_range = getObsData(register, 'C'+var, codes, log)
#           curr_p_range = p_range['value']
#           LLI = p_range['lli']
#           SSI = p_range['ssi']
#           prev_p_range = obsMemory[register[:3]]['type'][var]['C']['value']
#           curr_p_range = (alpha*curr_p_range + (1-alpha)*prev_p_range) / delta
#           register = setObsData(register, curr_p_range, LLI, SSI, 'C'+var, codes, log)
#     if updateMemory:
#       for var in codes[register[0]]:
#         # Após atualizar o registro memorizamos o estado do registro lido
#         for index in codes[register[0]][var]:
#           if index+var in types[register[0]]:
#             data = getObsData(in_register, index+var, codes, log)
#             updateObsRegisterMemory(in_register[:3], index+var, data, epoachTime, obsMemory, log)
#     out_epoach += [register]
#   return out_epoach
# 
# def lucas_h2(filename, k = 10000000, DC = 1.5, output_prefix = "output_"):
#   """
#   Esta rotina reproduz o pipeline sugerido pelo Lucas com um ajuste no tempo das
#   épocas. EM sua primeira proposta de processamento de resultados do matheus.
#   Isto reduz fase e pseudo-distância para um segundo proximo do inteiro.
#     filename é o nome do arquivo que será processado
#     k é um valor constante para a início da fase de um satélite, cujo intervalo
#       de tempo para a última vez que foi observado ultrapassa um limite DC
#     DC é o limite para o intervalo de tempo entre as observacões (opcional)
#     output_prefix é prefixo a ser anexado ao arquivo salvo (opcional)
#   """
#   start = datetime.now()
#   matheus(filename,k,DC,"~")
#   filename = "~" + filename
#   memory = {}
#   dc = timedelta(seconds=int(DC), microseconds=int((DC - int(DC))*10**6))
#   logfile = open("lucas.log","a")
#   logfile.write(f"Processamento iniciado em {start}.\n")
#   # Processando header
#   header = getHeader(filename, logfile)
#   if not header:
#     logfile.close()
#     return
#   obsTypes = getObsTypes(header, logfile)
#   if not obsTypes:
#     logfile.close()
#     return
#   codes = mapObsCodes(obsTypes, logfile)
#   if not codes:
#     logfile.close()
#     return
#   #if not loadGlonass_k(header, logfile):
#   #  logfile.close()
#   #  return
#   update_header = True
#   # Processando dados
#   output = open(output_prefix + filename, "w")
#   with open(filename) as file:
#     # A primeira época exige acesso indexado e não será gravada
#     epoca = getNextEpoach(file, len(header), log=logfile)
#     # Para todas as demais épocas faz-se:
#     while epoca:
#       # Combinar o tempo das épocas
#       epoca = combineEpoachTime(epoca, memory, k, dc, codes, obsTypes,
#                                 log = logfile)
#       # Se a época for a primeira vamos memorizar seu tempo e alterar no header
#       if update_header and len(epoca) > 1:
#         iniTime = getEpoachTime(epoca,logfile)
#         header = setInitialTime(header, iniTime, log = logfile)
#         write(output, header)
#         update_header = False
#       write(output, epoca)
#       epoca = getNextEpoach(file, log = logfile)
#   output.close()
#   logfile.write(f"Processo executado com sucesso em {(datetime.now() - start).total_seconds()} segundos.\n")
#   logfile.close()
#   os.rename(output_prefix+filename, output_prefix+filename[1:])
#   os.remove(filename)
# 
# def lucas_h1(filename, k = 10000000, DC = 1.5, output_prefix = "output_"):
#   """
#   Esta rotina reproduz o pipeline sugerido pelo Lucas com um ajuste no tempo das
#   épocas. Isto reduz fase e pseudo-distância para um segundo proximo do inteiro.
#     filename é o nome do arquivo que será processado
#     k é um valor constante para a início da fase de um satélite, cujo intervalo
#       de tempo para a última vez que foi observado ultrapassa um limite DC
#     DC é o limite para o intervalo de tempo entre as observacões (opcional)
#     output_prefix é prefixo a ser anexado ao arquivo salvo (opcional)
#   """
#   start = datetime.now()
#   memory = {}
#   dc = timedelta(seconds=int(DC), microseconds=int((DC - int(DC))*10**6))
#   logfile = open("lucas.log","a")
#   logfile.write(f"Processamento iniciado em {start}.\n")
#   # Processando header
#   header = getHeader(filename, logfile)
#   if not header:
#     logfile.close()
#     return
#   obsTypes = getObsTypes(header, logfile)
#   if not obsTypes:
#     logfile.close()
#     return
#   codes = mapObsCodes(obsTypes, logfile)
#   if not codes:
#     logfile.close()
#     return
#   #if not loadGlonass_k(header, logfile):
#   #  logfile.close()
#   #  return
#   update_header = True
#   # Processando dados
#   output = open(output_prefix + filename, "w")
#   with open(filename) as file:
#     # A primeira época exige acesso indexado e não será gravada
#     epoca = getNextEpoach(file, len(header), log=logfile)
#     # Para todas as demais épocas faz-se:
#     while epoca:
#       # Reconstruir a fase e reduzir o tempo da época
#       epoca = updateCarrierPhase(epoca, memory, k, dc, codes, obsTypes,
#                                  update_header, log = logfile)
#       epoca = reduceEpoachTime(epoca, memory, k, dc, codes, obsTypes,
#                                log = logfile)
#       # Se a época for a primeira vamos memorizar seu tempo e alterar no header
#       if update_header and len(epoca) > 1:
#         iniTime = getEpoachTime(epoca,logfile)
#         header = setInitialTime(header, iniTime, log = logfile)
#         write(output, header)
#         update_header = False
#       write(output, epoca)
#       epoca = getNextEpoach(file, log = logfile)
#   output.close()
#   logfile.write(f"Processo executado com sucesso em {(datetime.now() - start).total_seconds()} segundos.\n")
#   logfile.close()
# 
# def lucas_h0(filename, k = 10000000, DC = 1.5, output_prefix = "output_"):
#   """
#   Esta rotina reproduz o pipeline sugerido pelo Lucas com um ajuste no tempo das
#   épocas. EM sua primeira proposta de processamento de resultados do matheus.
#   Isto reduz fase e pseudo-distância para um segundo proximo do inteiro.
#     filename é o nome do arquivo que será processado
#     k é um valor constante para a início da fase de um satélite, cujo intervalo
#       de tempo para a última vez que foi observado ultrapassa um limite DC
#     DC é o limite para o intervalo de tempo entre as observacões (opcional)
#     output_prefix é prefixo a ser anexado ao arquivo salvo (opcional)
#   """
#   start = datetime.now()
#   matheus(filename,k,DC,"~")
#   filename = "~" + filename
#   memory = {}
#   dc = timedelta(seconds=int(DC), microseconds=int((DC - int(DC))*10**6))
#   logfile = open("lucas.log","a")
#   logfile.write(f"Processamento iniciado em {start}.\n")
#   # Processando header
#   header = getHeader(filename, logfile)
#   if not header:
#     logfile.close()
#     return
#   obsTypes = getObsTypes(header, logfile)
#   if not obsTypes:
#     logfile.close()
#     return
#   codes = mapObsCodes(obsTypes, logfile)
#   if not codes:
#     logfile.close()
#     return
#   #if not loadGlonass_k(header, logfile):
#   #  logfile.close()
#   #  return
#   update_header = True
#   # Processando dados
#   output = open(output_prefix + filename, "w")
#   with open(filename) as file:
#     # A primeira época exige acesso indexado e não será gravada
#     epoca = getNextEpoach(file, len(header), log=logfile)
#     # Para todas as demais épocas faz-se:
#     while epoca:
#       # Reduzir o tempo da época
#       epoca = reduceEpoachTime(epoca, memory, k, dc, codes, obsTypes,
#                                log = logfile)
#       # Se a época for a primeira vamos memorizar seu tempo e alterar no header
#       if update_header and len(epoca) > 1:
#         iniTime = getEpoachTime(epoca,logfile)
#         header = setInitialTime(header, iniTime, log = logfile)
#         write(output, header)
#         update_header = False
#       write(output, epoca)
#       epoca = getNextEpoach(file, log = logfile)
#   output.close()
#   logfile.write(f"Processo executado com sucesso em {(datetime.now() - start).total_seconds()} segundos.\n")
#   logfile.close()
#   os.rename(output_prefix+filename, output_prefix+filename[1:])
#   os.remove(filename)
# 
# lucas = lucas_h0
# 
# def matheus(filename, k = 10000000, DC = 1.5, output_prefix = "output_"):
#   """
#   Esta rotina reproduz o pipeline original do Matheus com um tempo de reinicio
#   variável. O código original assumia os seguintes hiperparâmetros:
#     filename é o nome do arquivo que será processado
#     k é um valor constante para a início da fase de um satélite, cujo intervalo
#       de tempo para a última vez que foi observado ultrapassa um limite DC
#     DC é o limite para o intervalo de tempo entre as observacões (opcional)
#     output_prefix é prefixo a ser anexado ao arquivo salvo (opcional)
#   """
#   start = datetime.now()
#   memory = {}
#   dc = timedelta(seconds=int(DC), microseconds=int((DC - int(DC))*10**6))
#   logfile = open("matheus.log","a")
#   logfile.write(f"Processamento iniciado em {start}.\n")
#   # Processando header
#   header = getHeader(filename, logfile)
#   if not header:
#     logfile.close()
#     return
#   obsTypes = getObsTypes(header, logfile)
#   if not obsTypes:
#     logfile.close()
#     return
#   codes = mapObsCodes(obsTypes)
#   if not codes:
#     logfile.close()
#     return
#   output = open(output_prefix + filename, "w")
#   write(output, header)
#   # Processando dados
#   with open(filename) as file:
#     # Da primeira época
#     epoca = getNextEpoach(file, len(header), log=logfile)
#     epoca = updateCarrierPhase(epoca, memory, k, dc, codes, obsTypes,
#                                log = logfile)
#     for line in epoca:
#       output.write(line)
#     # Das demais épocas
#     epoca = getNextEpoach(file, log = logfile)
#     while epoca:
#       epoca = updateCarrierPhase(epoca, memory, k, dc, codes, obsTypes,
#                                  log = logfile)
#       write(output, epoca)
#       epoca = getNextEpoach(file, log = logfile)
#   output.close()
#   logfile.write(f"Processo executado com sucesso em {(datetime.now() - start).total_seconds()} segundos.\n")
#   logfile.close()
# 
# def satelliteSystemIdentifier():
#   """ Para uma identificação clara e inequívoca, os satélites individuais são
#   identificados por um caracter identificador de sistema, cujo domínio está
#   restrito às chaves retornadas por este método (até a versão 3.05 do formato
#   RINEX). Adotamos um dicionário para o formato de retorno de modo a permitir a
#   determinação do sistema relacionado a cada caracter. Cabe ressaltar que cada
#   satélite individual é identificado pelo caractér identificador de sistema
#   seguido por úm número com dois dígitos decimais indicando o código PRN ou
#   número de slot.
#   """
#   return {'G':'GPS',
#           'R':'GLONASS',
#           'S':'SBAS payload',
#           'E':'Galileo',
#           'C':'BeiDou',
#           'J':'QZSS',
#           'I':'IRNSS'}
# 
# def types():
#   return {"C":"pseudo-range",
#           "L":"carrier phase",
#           "D":"doppler",
#           "S":"signal strength",
#           "X":"channel number"}
# 
# # Variáveis globais importantes deste módulo
# stl_m = dict()
# glonass_k = {"R01":+1,
#              "R02":-4,
#              "R03":+5,
#              "R04":+6,
#              "R05":+1,
#              "R06":-4,
#              "R07":+5,
#              "R08":+6,
#              "R09":-2,
#              "R10":-7,
#              "R11":+0,
#              "R12":-1,
#              "R13":-2,
#              "R14":-7,
#              "R15":+0,
#              "R16":-1,
#              "R17":+4,
#              "R18":-3,
#              "R19":+3,
#              "R20":+2,
#              "R21":+4,
#              "R22":-3,
#              "R23":+3,
#              "R24":+2}
# 
# def loadGlonass_k(header, var = glonass_k, log = open("RinexRemake.log","a")):
#   """ Atualiza os slots dos satélite no sistema GLONASS caso existam metadados
#   adequados no cabeçalho.
#     header é uma lista com as linhas do cabeçalho
#     var é a variavel que será atualizada pelo método (opcional)
#     log é o nome do arquivo para eventuais registros de erros (opcional)
#   """
#   res = {}
#   p_line = []
#   for i, line in enumerate(header):
#     line = line.replace("\n","")
#     if "GLONASS SLOT / FRQ #" in line[60:]:
#       var_names = line[:60].split()
#       if not p_line:
#         try:
#           var_len = int(var_names[0])
#           if var_len > len(var_names) - 1:
#             p_line = var_names[1:]
#           else:
#             for i in range(len(var_names)):
#               res[var_names[i*2]] = int(var_names[i*2+1])
#         except:
#           log.write(f"Impossível decodificar definições de slot GLONASS no cabeçalho.\n")
#           return False
#       else:
#         p_line += var_names
#         if len(p_line) == var_len:
#           for i in range(len(var_names)):
#             res[var_names[i*2]] = int(var_names[i*2+1])
#           p_line = []
#   if not p_line:
#     var = res
#     return True
#   log.write(f"Impossível decodificar definições de slot GLONASS no cabeçalho.\n")
#   return False
# 
# def g1(k):
#   """ Funcão para determinar a frequência individual do satélite no sistema
#   GLONASS em banda G1.
#     k é o slot do satélite
#   """
#   if type(k) != int or k < -7 or k > 12:
#     return 0.0
#   return 1602.0+k*9/16
# 
# def g2(k):
#   """ Funcão para determinar a frequência individual do satélite no sistema
#   GLONASS em banda G2.
#     k é o slot do satélite
#   """
#   if type(k) != int or k < -7 or k > 12:
#     return 0.0
#   return 1246.0+k*7/16
# 
# def getFrequency(ssi, var, log = open("RinexRemake.log","a")):
#   """ Retorna o valor da frequência tabelada dado um identificador do sistema de
#   satélites e o código da variável armazenada. Retorna zero se não for possível
#   determinar o valor da frequência solicitada.
#     ssi é o identificador do sistema de satélites
#     var é o código da variavel observada considerando os dois últimos caracteres ("1C" para a variável "D1C", por exemplo)
#     log é o nome do arquivo para eventuais registros de erros (opcional)
#   """
#   systems = satelliteSystemIdentifier()
#   if not ssi in systems:
#     log.write(f"Sistema {ssi} inderteminado.\n")
#     return 0.0
#   if type(var) != str or len(var) != 2:
#     log.write(f"Variável X{var} não atende aos requisitos para busca.\n")
#     return 0.0
#   table = {'G':{"1":(1575.42,"CSLXPWYMN"),
#                 "2":(1227.60,"CDSLXPWYMN"),
#                 "5":(1176.45,"IQX")},
#            'R':{"1":(g1,"CP"),
#                 "2":(g2,"CP"),
#                 "3":(1202.025,"IQX"),
#                 "4":(1600.995,"ABX"),
#                 "6":(1248.06,"ABX")},
#            'E':{"1":(1575.42,"ABCXZ"),
#                 "5":(1176.45,"IQX"),
#                 "6":(1278.75,"ABCXZ"),
#                 "7":(1207.140,"IQX"),
#                 "8":(1191.795,"IQX")},
#            'S':{"1":(1575.42,"C"),
#                 "5":(1176.45,"IQX")},
#            'J':{"1":(1575.42,"CSLXZB"),
#                 "2":(1227.60,"SLX"),
#                 "5":(1176.45,"IQXDPZ"),
#                 "6":(1278.75,"SLXEZ")},
#            'C':{"1":(1575.42,"DPXSLZ"),
#                 "2":(1561.098,"IQX"),
#                 "5":(1176.45,"DPX"),
#                 "6":(1268.52,"IQXDPZ"),
#                 "7":(1207.140,"IQXDPZ"),
#                 "8":(1191.795,"DPX")},
#            'I':{"1":(1176.45,"ABCX"),
#                 "5":(2492.028,"ABCX")}}
#   if var[0] in table[ssi]:
#     freq, val = table[ssi][var[0]]
#     if var[1] in val:
#       return freq
#   log.write(f"Impossível buscar frequência para X{var} em {systems[ssi]}.\n")
#   return 0.0
# 
# def getObsData(obsRegister, obsCode, obsCodeMap,
#                log = open("RinexRemake.log","a")):
#   try:
#     ssi, data = obsRegister[0], obsRegister[3:]
#     idx = obsCodeMap[ssi][obsCode[1:]][obsCode[0]]
#     if obsCode[0] == "F":
#       return idx
#     elif idx >= 0:
#       obsData = data[idx*16:(idx+1)*16]
#       value = float(obsData[:14]) if is_float(obsData[:14]) else float('nan')
#       lli = obsData[14] if len(obsData) > 14 else ''
#       ssi = obsData[15] if len(obsData) > 15 else ''
#       return dict(src=obsData, value=value, lli=lli, ssi=ssi)
#   except:
#     pass
#   log.write(f"Inviável recuperar {obsCode} no registro: {obsRegister}")
#   if obsCode[0] == 'X':
#     obsCode[0] = "1"
#   return None
# 
# def setObsData(obsRegister, value, LLI, SSI, obsCode, obsCodeMap,
#                log = open("RinexRemake.log","a")):
#   try:
#     ssi, data = obsRegister[0], obsRegister[3:]
#     idx = obsCodeMap[ssi][obsCode[1:]][obsCode[0]]
#     obsData = "%14.3f%s%s" % (value,LLI,SSI)
#     if len(data[idx*16:(idx+1)*16]) == 16:
#       data = data[:idx*16] + obsData + data[(idx+1)*16:]
#       return obsRegister[:3] + data
#     elif len(data[idx*16:(idx+1)*16]) > 0:
#       data = data[:idx*16] + obsData
#       data = data + "\n" if not "\n" in data else data
#       return obsRegister[:3] + data
#     else:
#       data = data.replace("\n"," ")
#       data += " "*(idx*16 - len(data)) + obsData
#       data = data + "\n" if not "\n" in data else data
#       return obsRegister[:3] + data
#   except:
#     pass
#   log.write(f"Inviável alterar {obsCode} no registro: {obsRegister}")
#   return None
# 
# def getNextEpoach(file, index = 0, obsTypes = satelliteSystemIdentifier().keys(),
#                   log = open("RinexRemake.log","a")):
#   """ Lê uma época específica do arquivo fornecido e retorna uma lista de linhas
#   da época.
#     file é o arquivo para leitura fornecido
#     obsTypes é uma relação dos tipos disponíveis nos registros de observações (opcional)
#     index é uma indicação da linha no arquivo onde a primeira época se inicia (opcional)
#     log é o nome do arquivo para eventuais registros de erros (opcional)
#   """
#   for i in range(index):
#     file.readline()
#   e_list = [file.readline()]
#   # Identificando término de arquivo ou linha em branco ao buscar próxima época
#   if not e_list[0].rstrip():
#     return None
#   # Testar se essa linha é de inicio de uma época
#   if e_list[0][0] != ">":
#     log.write("Não é possivel resgatar uma época no arquivo.\n")
#     return None
#   # Recuperar o número de satélites da época
#   try:
#     n_sat = int(e_list[0].split()[8])
#   except:
#     log.write("Houve falha ao determinar o número de satélites em uma época no arquivo.\n")
#     return None
#   # Ler os satélites da época
#   for i in range(n_sat):
#     e_list.append(file.readline())
#     # Evitar falhas de leitura por antecipação do fim de arquivo ou de nova época
#     if not e_list[-1].rstrip() or e_list[-1][0] == ">":
#       log.write("O número de satélites numa época parece incorreto no arquivo.\n")
#       return None
#     # Verificar se os identificadores de sistemas são válidos
#     if not (e_list[-1][0] in obsTypes):
#       log.write("Observação inválida no arquivo.\n")
#       return None
#   return e_list
# 
# def getEpoachTime(epoach, log = open("RinexRemake.log","a")):
#   if type(epoach) == list and len(epoach) > 0 and type(epoach[0]) == str:
#     s = epoach[0].split()
#     if len(s) == 9:
#       try:
#         year, month, day, hour, minute = [int(value) for value in s[1:6]]
#         second, microsecond = [int(value) for value in s[6].split(".")]
#         return datetime(year, month, day, hour, minute, second, microsecond//10)
#       except:
#         pass
#   log.write("Impossível determinar o tempo para uma epoca.\n")
#   return None
# 
# def getInitialTime(header, log = open("RinexRemake.log","a")):
#   """ Lê e retorna o tempo de início registrado na lista com linhas do cabeçalho
#   fornecida.
#     header é uma lista com as linhas do cabeçalho
#     log é o nome do arquivo para eventuais registros de erros (opcional)
#   """
#   for line in header:
#     if "TIME OF FIRST OBS" in line[60:]:
#       s = line[:60].split()
#       if len(s) == 7:
#         try:
#           year, month, day, hour, minute = [int(value) for value in s[0:5]]
#           second, microsecond = [int(value) for value in s[5].split(".")]
#           return datetime(year, month, day, hour, minute, second, microsecond//10)
#         except:
#           pass
#   log.write("Impossível determinar o tempo inicial.\n")
#   return None
# 
# def setEpoachTime(epoach, t, log = open("RinexRemake.log","a")):
#   try:
#     line = epoach[0]
#     s = line.split()
#     if len(s) == 9:
#       p = "> %4d %2d %2d %2d %2d %2d.%07d %s %s\n"
#       d = p % (t.year, t.month, t.day, t.hour, t.minute,
#                t.second, t.microsecond*10, s[7], s[8])
#       return [d] + epoach[1:]
#   except:
#     pass
#   log.write("Impossível alterar o tempo para uma epoca.\n")
#   return None
# 
# def setInitialTime(header, t, log = open("RinexRemake.log","a")):
#   """ Altera e retorna o tempo de início na lista com linhas do cabeçalho
#   fornecida.
#     header é uma lista com as linhas do cabeçalho
#     t é o novo tempo a ser registrado na listacom as linhas do cabeçalho
#     log é o nome do arquivo para eventuais registros de erros (opcional)
#   """
#   idtt = "TIME OF FIRST OBS"
#   try:
#     for i,line in enumerate(header):
#       if idtt in line[60:]:
#         s = line[:60].split()
#         if len(s) == 7:
#           p = "  %4d    %2d    %2d    %2d    %2d   %2d.%07d     %s              "
#           d = p % (t.year, t.month, t.day, t.hour, t.minute,
#                    t.second, t.microsecond*10, s[6])
#           return header[:i] + [d[:60] + idtt + "\n"] + header[i+1:]
#   except:
#     pass
#   log.write("Impossível alterar o tempo inicial.\n")
#   return None
# 
# def getEpoachDelta(e0, e1, log = open("RinexRemake.log","a")):
#   try:
#     t0 = getEpoachTime(e0, log)
#     t1 = getEpoachTime(e1, log)
#     d = t1 - t0
#     return d.total_seconds()
#   except:
#     return None
# 
# def getObsRegisterDelta(obsRegister, obsDatetime, obsMemory = stl_m,
#                         log = open("RinexRemake.log","a")):
#   if obsRegister[:3] in obsMemory:
#     d = obsDatetime - obsMemory[obsRegister[:3]]['datetime']
#     return d.total_seconds()
#   else:
#     return float('inf')
# 
# def updateObsRegisterMemory(obsId, obsCode, obsData, obsDatetime, obsMemory = stl_m,
#                     log = open("RinexRemake.log","a")):
#   if obsId in obsMemory:
#     obsMemory[obsId]['datetime'] = obsDatetime
#   else:
#     obsMemory[obsId] = {'datetime':obsDatetime, 'type':dict()}
#   if not obsCode[1:] in obsMemory[obsId]['type']:
#     obsMemory[obsId]['type'][obsCode[1:]] = {t:-1 for t in types()}
#   obsMemory[obsId]['type'][obsCode[1:]][obsCode[0]] = obsData
# 
# def getHeader(filename, log = open("RinexRemake.log","a")):
#   """ Lê cabeçalho na origem e retorna lista das linhas de cabeçalho no arquivo.
#   Isso requer os seguintes argumentos:
#     filename é o nome ou caminho para o arquivo que será analisado
#     log é o nome do arquivo para eventuais registros de erros (opcional)
#   """
#   h_list = []
#   try:
#     with open(filename, "r") as source:
#       is_header_line = True
#       for i, line in enumerate(source):
#         if i == 0:
#           if not ("RINEX VERSION / TYPE" in line[60:]):
#             log.write(f"Arquivo {filename} é inválido, pois não define RINEX VERSION / TYPE de forma adequada.\n")
#             return None
#           version, ftype = line.split()[:2]
#           if float(version) < 3.0:
#             log.write(f"A versão do arquivo {filename} deve ser 3 ou superior.\n")
#             return None
#           if not "OBSERVATION" in ftype:
#             log.write(f"O arquivo {filename} não é do subtipo de arquivo de dados de observações.\n")
#             return None
#         if is_header_line:
#           h_list.append(line)
#           if "END OF HEADER" in line[60:]:
#             is_header_line = False
#           elif line[0] == '>':
#             log.write(f"O arquivo {filename} parece mal formado (terminador de cabeçalho não encontrado).\n")
#             return None
#         elif line[0] == '>':
#           break
#         else:
#           log.write(f"O arquivo {filename} parece mal formado (após o cabeçalho deveria existir uma época).\n")
#           return None
#   except:
#     log.write(f"O arquivo {filename} não foi encontrado.\n")
#     return None
#   return h_list
# 
# def getObsTypes(header, log = open("RinexRemake.log","a")):
#   """ Identifica e retorna um dicionário com as variaveis de cada tipo de
#   observação descrito no cabeçalho.
#     header é uma lista com as linhas do cabeçalho
#     log é o nome do arquivo para eventuais registros de erros (opcional)
#   """
#   vars = {}
#   p_line = []
#   for i, line in enumerate(header):
#     line = line.replace("\n","")
#     if "SYS / # / OBS TYPES" in line[60:]:
#       var_names = line[:60].split()
#       if not p_line:
#         try:
#           var_key = var_names[0]
#           var_len = int(var_names[1])
#           if var_len > len(var_names) - 2:
#             p_line = var_names[2:]
#           else:
#             vars[var_key] = var_names[2:]
#         except:
#           log.write(f"Impossível ler o número de variáveis nas definições de tipo no cabeçalho.\n")
#           return None
#       else:
#         p_line += var_names
#         if len(p_line) == var_len:
#           vars[var_key] = list(p_line)
#           p_line = []
#         elif len(p_line) > var_len:
#           log.write(f"O número de variáveis nas definições de tipo é maior que o esperado no cabeçalho.\n")
#           return None
#   if not p_line:
#     return vars
#   else:
#     log.write(f"O número de variáveis nas definições de tipo é menor que o esperado no cabeçalho.\n")
#     return None
# 
# def mapObsCodes(obsTypes, log = open("RinexRemake.log","a")):
#   """ Identifica, agrupa e retorna as variáveis de observações por código dado o
#   dicionário com as variaveis de cada tipo de observação.
#     obsTypes é um dicionário com as variaveis de cada tipo de observação
#     log é o nome do arquivo para eventuais registros de erros (opcional)
#   """
#   codes = dict()
#   for key in obsTypes:
#     typeCodes = set()
#     for elem in obsTypes[key]:
#       typeCodes.add(elem[1:])
#     codes[key] =  typeCodes
#   r_vars = {}
#   for key in obsTypes:
#     r_vars[key] = {}
#     for code in codes[key]:
#       r_vars[key][code] = {t:-1 for t in types()}
#       F = getFrequency(key,code, log=log)
#       if not F:
#         return None
#       r_vars[key][code]['F'] = F
#       for i, var_name in enumerate(obsTypes[key]):
#         if var_name[1:] == code:
#           if var_name[0] in types():
#             r_vars[key][code][var_name[0]] = i
#           else:
#             log.write(f"Código de observação {var_name} desconhecido em {satelliteSystemIdentifier()[key]}.\n")
#             return None
#   return r_vars
# 
# def write(file, data, th = 1, log = open("RinexRemake.log","a")):
#   """ Rotina para gravação de bloco de dados em arquivo.
#   """
#   try:
#     if len(data) > th:
#       for line in data:
#         file.write(line)
#   except Exception as err:
#     log.write(f"Erro não esperado {type(err)} = {err}.\n")
# 
# def is_float(n):
#   try:
#     float(n)
#     return True
#   except ValueError:
#     return False
#

"""## Seção reservada para testes planejados"""

import os
os.mkdir('testes')

os.system('cp RinexRemake.py testes/RinexRemake.py')
os.chdir('testes')

from RinexRemake import *

"""### Dados de exemplo (sem erros)"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile slice_of_data.23o
#      3.03           OBSERVATION DATA    M: Mixed            RINEX VERSION / TYPE
# Geo++ RINEX Logger  Geo++               20231117 124520 UTC PGM / RUN BY / DATE
# ************************************************************COMMENT
# This file was generated by the Geo++ RINEX Logger App       COMMENT
# for Android devices (Version 2.1.6). If you encounter       COMMENT
# any issues, please send an email to android@geopp.de        COMMENT
# Filtering Mode: MORE                                        COMMENT
# ************************************************************COMMENT
# 91877 (Shopping Downtown)                                   MARKER NAME
# 91877                                                       MARKER NUMBER
# CARTO               UERJ                                    OBSERVER / AGENCY
# unknown             samsung             SM-G780G            REC # / TYPE / VERS
# unknown             SM-G780G                                ANT # / TYPE
#   4273785.6996 -4029706.9144 -2477046.1636                  APPROX POSITION XYZ
#         0.1500        0.0000        0.0000                  ANTENNA: DELTA H/E/N
# G    8 C1C L1C D1C S1C C5Q L5Q D5Q S5Q                      SYS / # / OBS TYPES
# R    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES
# E   12 C1B L1B D1B S1B C1C L1C D1C S1C C5Q L5Q D5Q S5Q      SYS / # / OBS TYPES
# C    4 C2I L2I D2I S2I                                      SYS / # / OBS TYPES
# J    8 C1C L1C D1C S1C C5Q L5Q D5Q S5Q                      SYS / # / OBS TYPES
#   2023    11    17    12    45   38.4408343     GPS         TIME OF FIRST OBS
#  24 R01  1 R02 -4 R03  5 R04  6 R05  1 R06 -4 R07  5 R08  6 GLONASS SLOT / FRQ #
#     R09 -2 R10 -5 R11  0 R12 -1 R13 -2 R14 -7 R15  0 R16 -1 GLONASS SLOT / FRQ #
#     R17  4 R18 -3 R19  3 R20  2 R21  4 R22 -3 R23  3 R24  2 GLONASS SLOT / FRQ #
# G L1C                                                       SYS / PHASE SHIFT
# G L5Q -0.25000                                              SYS / PHASE SHIFT
# R L1C                                                       SYS / PHASE SHIFT
# E L1B                                                       SYS / PHASE SHIFT
# E L1C +0.50000                                              SYS / PHASE SHIFT
# E L5Q -0.25000                                              SYS / PHASE SHIFT
# C L2I                                                       SYS / PHASE SHIFT
# J L1C                                                       SYS / PHASE SHIFT
# J L5Q -0.25000                                              SYS / PHASE SHIFT
#  C1C    0.000 C1P    0.000 C2C    0.000 C2P    0.000        GLONASS COD/PHS/BIS
#                                                             END OF HEADER
# > 2023 11 17 12 45 38.4408343  3  1
# Geo++                                                       MARKER NAME
# > 2023 11 17 12 45 38.4408343  0 29
# C11  26792664.489                        2292.350          31.200
# C12  22609278.087                         842.128          47.600
# C22  26406372.014                        1766.700          31.100
# C24  22658536.986                        1917.392          40.200
# C26  21747227.273                        -925.264          43.800
# C35  23081018.608                       -1918.822          39.200
# E05                                                                  27067649.721                       -1501.958          41.300
# E10                                                                  23696220.913                        -998.164          50.400
# E11                                                                  22360834.082                         508.253          42.300
# E12                                                                  25071319.751                       -2051.729          35.400
# E24                                                                  23771802.189                         217.282          45.500
# E25                                                                  25257533.738                        2038.385          50.700
# E31                                                                  26214778.551                       -1624.426          38.600
# E36                                                                  26189675.130                        2488.666          42.600
# G05  22815764.640                        2299.204          39.300
# G06  24315633.802                       -3450.804          35.600
# G11  21771086.855                       -2437.325          42.700
# G12  20953337.271                         885.738          47.600
# G18  25067133.450                        3587.609          46.000
# G20  21972447.256                         683.442          40.300
# G24  21876821.556                       -2667.963          47.300
# G25  22062661.702                        2559.113          48.000
# G29  22820865.009                        1107.831          48.400
# R09  19238581.672                        -516.487          46.700
# R10  20374102.567                        2892.037          46.600
# R16  22447769.098                       -3596.050          31.600
# R19  22795912.983                       -3636.850          28.400
# R20  19691719.471                        -920.576          40.200
# R21  22112652.094                        2475.798          48.400
# > 2023 11 17 12 45 39.4408343  0 29
# C11  26792227.942                        2293.200          31.900
# C12  22609118.548                         842.004          46.500
# C22  26405934.867                        1769.866          38.600
# C24  22658179.284                        1917.056          52.000
# C26  21747410.096                        -925.838          41.900
# C35  23081382.207                       -1919.030          48.500
# E05                                                                  27067937.472                       -1500.676          41.300
# E10                                                                  23696408.833                        -999.875          46.200
# E11                                                                  22360741.696                         507.614          40.500
# E12                                                                  25071723.822                       -2052.547          39.300
# E24                                                                  23771763.166                         216.856          45.500
# E25                                                                  25257143.359                        2038.077          46.400
# E31                                                                  26215076.495                       -1624.616          39.100
# E36                                                                  26189201.109                        2489.306          36.500
# G05  22815306.507                        2301.596          33.900
# G06  24316297.493                       -3451.360          38.800
# G11  21771547.287                       -2438.133          44.700
# G12  20953169.638                         885.062          46.900
# G18  25066444.177                        3589.078          42.700
# G20  21972347.076                         683.219          44.100
# G24  21877329.955                       -2667.756          43.000
# G25  22062176.288                        2558.890          51.000
# G29  22820654.805                        1107.784          51.200
# R09  19238695.244                        -517.601          46.500
# R10  20373554.197                        2891.044          42.800
# R16  22448355.742                       -3594.950          28.400
# R19  22796646.825                       -3634.500          29.600
# R20  19691906.492                        -921.238          40.000
# R21  22112188.865                        2475.949          46.800
# > 2023 11 17 12 45 40.4408343  0 30
# C11  26791775.769                        2300.576          38.100
# C12  22608954.776                         846.205          47.200
# C22  26405593.018                        1773.052          43.200
# C24  22657810.154                        1920.481          52.200
# C26  21747587.188                        -922.479          48.000
# C35  23081750.866                       -1916.378          49.000
# E05                                                                  27068225.487                       -1494.594          44.500
# E10                                                                  23696599.415                        -995.214          48.100
# E11                                                                  22360640.880                         511.366          44.700
# E12                                                                  25072107.771                       -2050.031          46.900
# E24                                                                  23771722.908                         221.622          46.400
# E25                                                                  25256753.543                        2041.814          49.800
# E31                                                                  26215384.297                       -1620.587          37.700
# E36                                                                  26188729.150                        2494.185          41.000
# G05  22814856.133                        2302.695          45.500
# G06  24316947.058                       -3447.851          40.900
# G11  21772013.678                       -2435.776          50.600
# G12  20952998.371                         888.846          50.600
# G18  25065757.867                        3594.456          43.900
# G20  21972206.088                         686.564          39.500
# G24  21877842.814                       -2662.335          44.000
# G25  22061696.835                        2562.333          51.600
# G28  25591846.863                        2911.127          35.400
# G29  22820442.166                        1112.536          49.700
# R09  19238790.192                        -513.737          48.700
# R10  20373019.582                        2894.155          46.800
# R16  22448989.418                       -3589.929          45.200
# R19  22797282.599                       -3634.126          35.100
# R20  19692065.596                        -917.520          40.300
# R21  22111724.102                        2481.210          47.500
# > 2023 11 17 12 45 42.4408343  0 22
# E05                                                                  27068791.625                       -1512.454          43.500
# E10                                                                  23696977.883                       -1010.828          51.600
# E11                                                                  22360449.143                         495.448          44.700
# E12                                                                  25072890.359                       -2063.866          50.500
# E24                                                                  23771639.096                         205.178          51.200
# E25                                                                  25255977.510                        2027.048          50.000
# E31                                                                  26215995.703                       -1634.700          31.400
# E36                                                                  26187779.837                        2476.474          42.100
# G05  22814001.555                        2286.906          38.200
# G11  21772941.066                       -2450.227          54.700
# G12  20952664.832                         873.203          55.000
# G18  25064389.144                        3575.863          41.700
# G20  21971944.799                         670.058          43.300
# G24  21878859.241                       -2680.698          44.300
# G25  22060722.339                        2547.315          52.100
# G29  22820021.687                        1095.468          48.700
# R09  19238977.093                        -530.962          52.900
# R10  20371937.761                        2878.549          49.300
# R16  22450346.108                       -3607.200          39.600
# R19  22798655.779                       -3649.383          34.800
# R20  19692402.393                        -934.312          40.500
# R21  22110800.271                        2462.206          50.400
# > 2023 11 17 12 45 43.4408343  0 27
# C11  26790459.742                        2288.550          38.300
# C12  22608473.671                         837.634          48.100
# C24  22656708.478                        1912.600          50.100
# C26  21748122.679                        -930.661          50.900
# C35  23082858.361                       -1922.014          51.500
# E05                                                                  27069079.358                       -1504.652          44.300
# E10                                                                  23697170.881                       -1003.541          51.600
# E11                                                                  22360354.040                         502.624          44.900
# E12                                                                  25073280.320                       -2056.469          50.900
# E24                                                                  23771597.956                         212.622          51.200
# E25                                                                  25255593.708                        2034.682          48.900
# E31                                                                  26216301.423                       -1636.200          27.700
# E36                                                                  26187309.394                        2483.922          43.500
# G05  22813547.601                        2299.350          35.900
# G11  21773408.974                       -2442.209          54.900
# G12  20952496.280                         881.248          54.400
# G18  25063708.847                        3583.724          42.300
# G20  21971819.117                         677.897          42.400
# G24  21879366.121                       -2672.435          46.100
# G25  22060237.207                        2555.665          50.800
# G29  22819809.066                        1103.971          47.700
# R09  19239075.057                        -523.901          52.800
# R10  20371401.963                        2886.349          47.700
# R16  22451011.879                       -3598.828          37.900
# R19  22799334.740                       -3639.750          35.300
# R20  19692588.496                        -926.666          40.300
# R21  22110332.527                        2470.293          50.000
# > 2023 11 17 12 45 44.4408343  0 26
# C11  26790020.902                        2297.850          39.500
# C12  22608311.839                         845.023          49.000
# C24  22656339.790                        1920.170          48.900
# C26  21748298.114                        -923.348          51.100
# C35  23083226.563                       -1914.320          49.700
# E05                                                                  27069365.416                       -1495.974          44.400
# E10                                                                  23697359.807                        -995.442          53.500
# E11                                                                  22360255.765                         510.664          44.000
# E12                                                                  25073670.107                       -2048.218          49.700
# E24                                                                  23771557.541                         220.901          53.800
# E25                                                                  25255204.334                        2043.231          48.100
# E36                                                                  26186833.380                        2492.242          45.100
# G05  22813100.967                        2303.072          44.000
# G11  21773871.011                       -2434.721          54.000
# G12  20952327.553                         888.882          54.800
# G18  25063028.075                        3591.763          45.900
# G20  21971688.464                         685.775          45.000
# G24  21879873.127                       -2664.843          50.200
# G25  22059752.199                        2563.520          50.300
# G29  22819596.270                        1111.702          46.000
# R09  19239171.646                        -516.160          55.100
# R10  20370858.196                        2894.054          47.400
# R16  22451691.865                       -3591.191          44.900
# R19  22800021.921                       -3631.150          32.800
# R20  19692759.134                        -918.926          39.300
# R21  22109882.595                        2477.885          48.600
# > 2023 11 17 12 45 45.4408343  0 27
# C11  26789578.951                        2296.988          39.300
# C12  22608149.295                         844.126          48.400
# C24  22655972.188                        1919.017          48.600
# C26  21748477.034                        -924.500          50.500
# C35  23083595.550                       -1915.025          49.200
# E05                                                                  27069650.162                       -1496.423          43.900
# E10                                                                  23697548.919                        -996.425          53.000
# E11                                                                  22360159.774                         509.662          44.500
# E12                                                                  25074058.881                       -2049.019          48.200
# E24                                                                  23771516.113                         219.968          55.500
# E25                                                                  25254816.046                        2042.507          47.800
# E31                                                                  26216917.197                       -1622.003          45.400
# E36                                                                  26186362.350                        2491.331          45.400
# G05  22812662.014                        2302.150          45.200
# G11  21774339.230                       -2435.764          52.600
# G12  20952157.814                         887.990          54.900
# G18  25062339.994                        3591.078          45.200
# G20  21971552.901                         684.061          53.500
# G24  21880378.820                       -2665.903          50.800
# G25  22059261.382                        2562.739          50.000
# G29  22819390.855                        1110.871          45.900
# R09  19239271.421                        -517.509          54.700
# R10  20370309.819                        2892.938          46.900
# R16  22452365.742                       -3592.399          45.900
# R19  22800728.775                       -3632.050          31.500
# R20  19692936.255                        -920.147          39.700
# R21  22109420.258                        2476.674          48.900
# > 2023 11 17 12 45 46.4408344  0 27
# C11  26789166.204                        2290.209          39.200
# C12  22608017.752                         837.166          48.600
# C24  22655634.688                        1912.034          48.600
# C26  21748683.957                        -931.575          50.800
# C35  23083992.242                       -1921.783          49.500
# E05                                                                  27069966.510                       -1502.848          44.400
# E10                                                                  23697768.733                       -1003.376          53.300
# E11                                                                  22360094.486                         502.652          44.400
# E12                                                                  25074481.655                       -2055.952          48.100
# E24                                                                  23771502.689                         213.122          54.800
# E25                                                                  25254456.061                        2035.825          47.900
# E31                                                                  26217256.328                       -1628.830          45.400
# E36                                                                  26185918.123                        2484.457          45.700
# G05  22812254.962                        2295.185          45.900
# G11  21774830.356                       -2442.846          52.800
# G12  20952019.376                         881.033          54.800
# G18  25061689.811                        3584.276          45.300
# G20  21971452.238                         676.868          54.300
# G24  21880914.615                       -2672.866          50.700
# G25  22058803.366                        2555.973          49.900
# G29  22819211.346                        1104.001          46.400
# R09  19239396.201                        -525.077          55.400
# R10  20369801.137                        2885.701          47.600
# R16  22453056.830                       -3599.543          44.600
# R19  22801439.949                       -3639.400          30.800
# R20  19693135.383                        -927.480          39.400
# R21  22108979.629                        2469.354          48.600
# > 2023 11 17 12 45 47.4408344  0 27
# C11  26788725.568                        2288.304          39.000
# C12  22607855.025                         835.146          48.300
# C24  22655266.003                        1909.931          48.300
# C26  21748862.393                        -933.883          50.900
# C35  23084361.046                       -1923.533          49.100
# E05                                                                  27070249.273                       -1504.553          44.300
# E10                                                                  23697959.761                       -1005.632          53.400
# E11                                                                  22359997.113                         500.377          44.100
# E12                                                                  25074872.044                       -2058.013          48.300
# E24                                                                  23771461.976                         210.985          55.000
# E25                                                                  25254070.887                        2033.940          48.300
# E31                                                                  26217567.573                       -1630.914          44.100
# E36                                                                  26185445.111                        2482.369          45.900
# G05  22811818.524                        2293.219          44.800
# G11  21775296.293                       -2445.001          52.700
# G12  20951854.250                         878.928          55.000
# G18  25061009.641                        3582.295          45.700
# G20  21971319.489                         674.563          54.700
# G24  21881432.417                       -2674.969          51.200
# G25  22058316.862                        2554.104          50.100
# G29  22819000.352                        1102.083          47.300
# R09  19239499.988                        -527.710          55.500
# R10  20369257.973                        2883.392          47.700
# R16  22453721.529                       -3601.766          46.100
# R19  22802076.468                       -3640.500          32.000
# R20  19693307.224                        -929.935          40.600
# R21  22108518.908                        2467.092          49.700
# > 2023 11 17 12 45 48.4408344  0 27
# C11  26788288.444                        2292.046          39.700
# C12  22607696.108                         838.922          48.400
# C24  22654899.330                        1913.626          48.300
# C26  21749042.541                        -930.302          50.500
# C35  23084730.963                       -1919.512          48.800
# E05                                                                  27070540.345                       -1500.400          44.300
# E10                                                                  23698150.702                       -1001.966          53.600
# E11                                                                  22359904.151                         504.003          44.700
# E12                                                                  25075262.947                       -2054.214          48.500
# E24                                                                  23771422.976                         214.789          55.300
# E25                                                                  25253681.430                        2037.953          48.000
# E31                                                                  26217876.632                       -1627.065          43.100
# E36                                                                  26184974.709                        2486.202          45.700
# G05  22811382.299                        2297.112          45.000
# G11  21775760.645                       -2441.313          52.500
# G12  20951686.639                         882.720          54.700
# G18  25060328.786                        3586.210          45.600
# G20  21971192.650                         678.112          54.700
# G24  21881937.540                       -2671.193          51.600
# G25  22057830.872                        2558.123          50.300
# G29  22818790.770                        1106.089          46.600
# R09  19239599.193                        -524.413          55.400
# R10  20368719.219                        2887.030          47.700
# R16  22454397.234                       -3597.966          45.300
# R19  22802761.767                       -3641.300          33.700
# R20  19693471.184                        -926.290          39.800
# R21  22108059.599                        2470.844          48.600
# > 2023 11 17 12 45 49.4408344  0 27
# C11  26787845.588                        2296.161          39.700
# C12  22607531.759                         842.845          48.200
# C24  22654532.021                        1917.460          48.400
# C26  21749221.455                        -926.558          50.600
# C35  23085099.346                       -1915.321          48.600
# E05                                                                  27070822.987                       -1495.809          44.100
# E10                                                                  23698341.307                        -997.968          53.300
# E11                                                                  22359804.557                         507.929          44.700
# E12                                                                  25075653.514                       -2050.097          48.400
# E24                                                                  23771380.943                         218.918          55.000
# E25                                                                  25253293.136                        2042.316          48.100
# E31                                                                  26218185.955                       -1622.901          44.200
# E36                                                                  26184497.377                        2490.321          45.300
# G05  22810943.040                        2301.240          42.400
# G11  21776225.860                       -2437.421          53.100
# G12  20951516.594                         886.727          54.900
# G18  25059645.796                        3590.420          45.800
# G20  21971060.679                         681.862          54.600
# G24  21882444.426                       -2667.229          51.600
# G25  22057339.749                        2562.300          50.400
# G29  22818578.155                        1110.187          47.200
# R09  19239696.862                        -520.746          55.400
# R10  20368170.237                        2890.964          47.800
# R16  22455068.707                       -3594.030          45.700
# R19  22803459.921                       -3632.971          34.300
# R20  19693653.994                        -922.464          40.000
# R21  22107595.458                        2474.726          48.400
# > 2023 11 17 12 45 50.4408344  0 27
# C11  26787407.037                        2294.616          40.200
# C12  22607369.916                         841.187          48.400
# C24  22654164.221                        1915.735          48.300
# C26  21749400.476                        -928.417          50.700
# C35  23085466.037                       -1916.739          48.900
# E05                                                                  27071108.734                       -1497.049          44.200
# E10                                                                  23698530.522                        -999.712          53.500
# E11                                                                  22359707.470                         506.109          45.100
# E12                                                                  25076044.489                       -2051.670          48.200
# E24                                                                  23771339.617                         217.307          54.700
# E25                                                                  25252903.751                        2040.890          48.400
# E31                                                                  26218495.386                       -1624.543          44.100
# E36                                                                  26184021.352                        2488.666          44.900
# G05  22810509.586                        2299.566          42.800
# G11  21776688.785                       -2439.186          53.000
# G12  20951348.156                         885.068          55.200
# G18  25058965.012                        3588.945          45.500
# G20  21970931.214                         679.956          54.600
# G24  21882954.419                       -2668.918          52.000
# G25  22056855.030                        2560.857          50.300
# G29  22818367.446                        1108.690          47.100
# R09  19239785.047                        -522.907          55.300
# R10  20367630.356                        2889.079          48.000
# R16  22455746.283                       -3595.765          45.700
# R19  22804149.189                       -3634.445          34.300
# R20  19693826.720                        -924.446          40.200
# R21  22107132.324                        2472.727          48.400
# > 2023 11 17 12 45 51.4408344  0 27
# C11  26786964.820                        2293.677          40.700
# C12  22607210.104                         839.992          48.300
# C24  22653795.154                        1914.522          48.000
# C26  21749579.729                        -929.798          50.200
# C35  23085835.958                       -1917.672          48.600
# E05                                                                  27071391.416                       -1497.755          44.300
# E10                                                                  23698719.968                       -1000.957          53.700
# E11                                                                  22359610.014                         504.822          45.100
# E12                                                                  25076433.296                       -2052.771          48.400
# E24                                                                  23771299.122                         216.168          54.800
# E25                                                                  25252517.596                        2039.987          48.100
# E31                                                                  26218808.347                       -1625.658          44.500
# E36                                                                  26183548.557                        2487.579          44.700
# G05  22810070.367                        2298.609          44.900
# G11  21777153.141                       -2440.440          52.700
# G12  20951179.350                         883.881          55.100
# G18  25058279.364                        3587.941          45.300
# G20  21970801.681                         678.548          54.200
# G24  21883465.542                       -2670.103          51.700
# G25  22056367.245                        2559.894          49.700
# G29  22818153.071                        1107.679          46.700
# R09  19239887.853                        -524.590          55.600
# R10  20367096.403                        2887.727          47.600
# R16  22456440.879                       -3597.088          45.300
# R19  22804806.011                       -3635.700          33.400
# R20  19694004.474                        -925.910          40.100
# R21  22106667.922                        2471.370          48.600
# > 2023 11 17 12 45 52.4408344  0 22
# E05                                                                  27071678.709                       -1495.834          43.900
# E10                                                                  23698911.327                        -999.543          53.300
# E11                                                                  22359515.972                         506.164          44.000
# E12                                                                  25076825.817                       -2051.296          48.700
# E24                                                                  23771257.243                         217.706          54.800
# E25                                                                  25252130.356                        2041.737          48.200
# E31                                                                  26219119.024                       -1624.100          44.300
# E36                                                                  26183077.675                        2489.110          46.000
# G05  22809633.062                        2300.183          46.300
# G11  21777617.911                       -2439.080          53.000
# G12  20951013.358                         885.349          54.900
# G18  25057596.529                        3589.598          45.200
# G20  21970675.560                         679.777          54.600
# G24  21883970.485                       -2668.620          51.600
# G25  22055880.474                        2561.633          49.800
# G29  22817946.007                        1109.277          46.200
# R09  19239984.478                        -523.569          55.600
# R10  20366549.673                        2889.050          47.700
# R16  22457107.111                       -3595.609          46.400
# R19  22805491.429                       -3631.250          33.400
# R20  19694159.559                        -924.687          40.000
# R21  22106204.835                        2472.733          49.400
# > 2023 11 17 12 45 53.4408344  0 27
# C11  26786086.069                        2291.285          42.900
# C12  22606888.967                         837.410          47.300
# C24  22653060.603                        1904.488          50.200
# C26  21749935.523                        -932.762          50.200
# C35  23086571.889                       -1919.760          48.900
# E05                                                                  27071964.859                       -1499.451          44.700
# E10                                                                  23699100.644                       -1003.733          53.600
# E11                                                                  22359419.586                         501.932          43.700
# E12                                                                  25077218.993                       -2055.269          48.500
# E24                                                                  23771217.819                         213.629          54.500
# E25                                                                  25251739.275                        2037.943          48.300
# E31                                                                  26219427.358                       -1628.152          44.200
# E36                                                                  26182605.050                        2485.071          46.300
# G05  22809198.211                        2296.090          47.500
# G11  21778081.838                       -2443.264          52.700
# G12  20950842.024                         881.266          55.000
# G18  25056913.450                        3585.622          45.000
# G20  21970550.095                         675.432          55.200
# G24  21884479.980                       -2672.783          52.000
# G25  22055392.260                        2557.689          50.300
# G29  22817733.902                        1105.299          47.900
# R09  19240084.157                        -528.245          55.100
# R10  20366004.499                        2884.710          48.400
# R16  22457799.179                       -3599.949          45.500
# R19  22806191.892                       -3638.400          33.800
# R20  19694341.381                        -929.051          39.800
# R21  22105744.202                        2468.328          48.600
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile many_vars_data.22o
#      3.05           OBSERVATION DATA    M: MIXED            RINEX VERSION / TYPE
# GnssLogger v3.0.3.1 HUAWEI 10           20220225 154840 UTC PGM / RUN BY / DATE
# 91877 (Shopping Downtown)                                   MARKER NAME
# 91877                                                       MARKER NUMBER
# CARTO               UERJ                                    OBSERVER / AGENCY
# G   16 C1C L1C D1C S1C C2S L2S D2S S2S C2W L2W D2W S2W C5Q  SYS / # / OBS TYPES
#        L5Q D5Q S5Q                                          SYS / # / OBS TYPES
# R   12 C1C L1C D1C S1C C2P L2P D2P S2P C2C L2C D2C S2C      SYS / # / OBS TYPES
# E   16 C1C L1C D1C S1C C5Q L5Q D5Q S5Q C7Q L7Q D7Q S7Q C8Q  SYS / # / OBS TYPES
#        L8Q D8Q S8Q                                          SYS / # / OBS TYPES
# C    8 C2I L2I D2I S2I C7I L7I D7I S7I                      SYS / # / OBS TYPES
# J   12 C1C L1C D1C S1C C2S L2S D2S S2S C5Q L5Q D5Q S5Q      SYS / # / OBS TYPES
# S    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES
#                                                             END OF HEADER
# >

"""### Dados de exemplo para verificação do tratamento de erros"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile other_data.pnm
# P1
# 5 10
# 0111111100
# 0100000000
# 0111100000
# 0100000000
# 0111111100

# Commented out IPython magic to ensure Python compatibility.
# %%writefile v2_data.22o
#      2.03           OBSERVATION DATA    M                   RINEX VERSION / TYPE
# GnssLogger v3.0.3.1 HUAWEI 10           20220225 154840 UTC PGM / RUN BY / DATE
# 91877 (Shopping Downtown)                                   MARKER NAME
# 91877                                                       MARKER NUMBER
# CARTO               UERJ                                    OBSERVER / AGENCY
#                                                             END OF HEADER
# >

# Commented out IPython magic to ensure Python compatibility.
# %%writefile nav_data.22o
#      3.05           N: GNSS NAV DATA    E: GALILEO NAV DATA RINEX VERSION / TYPE
# NetR9 5.01 Receiver Operator 20150619 000000 UTC            PGM / RUN BY / DATE
# GAL .1248D+03 .5039D+00 .2377D-01 .0000D+00                 IONOSPHERIC CORR
# GAUT .3725290298D-08 .532907052D-14 345600 1849 E10 5       TIME SYSTEM CORR
#  16 17 1851 3                                               LEAP SECONDS
#                                                             END OF HEADER
# >

# Commented out IPython magic to ensure Python compatibility.
# %%writefile error_1_data.22o
#      3.03           OBSERVATION DATA    M                   RINEX VERSION / TYPE
# >

# Commented out IPython magic to ensure Python compatibility.
# %%writefile error_2_data.22o
#      3.03           OBSERVATION DATA    M                   RINEX VERSION / TYPE
# GnssLogger v3.0.3.1 HUAWEI 10           20220225 154840 UTC PGM / RUN BY / DATE
# 91877 (Shopping Downtown)                                   MARKER NAME
# 91877                                                       MARKER NUMBER
# CARTO               UERJ                                    OBSERVER / AGENCY
#                                                             END OF HEADER
# Texto sem sentido

# Commented out IPython magic to ensure Python compatibility.
# %%writefile error_3_data.22o
#      3.03           OBSERVATION DATA    M                   RINEX VERSION / TYPE
# GnssLogger v3.0.3.1 HUAWEI 10           20220225 154840 UTC PGM / RUN BY / DATE
# 91877 (Shopping Downtown)                                   MARKER NAME
# 91877                                                       MARKER NUMBER
# CARTO               UERJ                                    OBSERVER / AGENCY
# G    8 C1C L1C D1C S1C C5Q L5Q D5Q S5Q                      SYS / # / OBS TYPES
# R    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES
# C    4 C2I L2I D2I S2I                                      SYS / # / OBS TYPES
# E    A C1A L1A D1A S1A C5Q L5Q D5Q S5Q                      SYS / # / OBS TYPES
#                                                             END OF HEADER
# >

# Commented out IPython magic to ensure Python compatibility.
# %%writefile error_4_data.22o
#      3.03           OBSERVATION DATA    M                   RINEX VERSION / TYPE
# GnssLogger v3.0.3.1 HUAWEI 10           20220225 154840 UTC PGM / RUN BY / DATE
# 91877 (Shopping Downtown)                                   MARKER NAME
# 91877                                                       MARKER NUMBER
# CARTO               UERJ                                    OBSERVER / AGENCY
# G    8 C1C L1C D1C S1C C5Q L5Q D5Q S5Q                      SYS / # / OBS TYPES
# R    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES
# C    4 C2I L2I D2I S2I                                      SYS / # / OBS TYPES
# E    8 C1A L1A D1A S1A                                      SYS / # / OBS TYPES
#                                                             END OF HEADER
# >

# Commented out IPython magic to ensure Python compatibility.
# %%writefile error_5_data.22o
#      3.03           OBSERVATION DATA    M                   RINEX VERSION / TYPE
# GnssLogger v3.0.3.1 HUAWEI 10           20220225 154840 UTC PGM / RUN BY / DATE
# 91877 (Shopping Downtown)                                   MARKER NAME
# 91877                                                       MARKER NUMBER
# CARTO               UERJ                                    OBSERVER / AGENCY
# G    8 C1C L1C D1C S1C C5Q L5Q D5Q S5Q                      SYS / # / OBS TYPES
# R    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES
# C    4 C2I L2I D2I S2I                                      SYS / # / OBS TYPES
# E   16 C1C L1C D1C S1C C2S L2S D2S S2S C2W L2W D2W S2W C5Q  SYS / # / OBS TYPES
#        L5Q D5Q S5Q C1A L1A D1A S1A                          SYS / # / OBS TYPES
#                                                             END OF HEADER
# >

"""### Execução de testes

#### Rotinas para cabeçalho
"""

# Teste de rotinas de processamento do cabeçalho
header = getHeader("slice_of_data.23o")
for line in header:
  print(line, end="")

obsTypes = getObsTypes(header)
for key in obsTypes.keys():
  print(key, obsTypes[key])

# Segundo teste de rotinas para processamento de cabeçalho (com muitas variáveis)
header = getHeader("many_vars_data.22o")
for line in header:
  print(line, end="")

obsTypes = getObsTypes(header)
for key in obsTypes.keys():
  print(key, obsTypes[key])

# Testes adicionais para processamento de cabeçalho (tratamento de erros)
logger = open("erro_ao_ler_cabeçalho.log","w")

header = getHeader("error_1_data.22o", logger)
if header:
  print("Teste de falha 1 falhou!")

header = getHeader("error_2_data.22o", logger)
if header:
  print("Teste de falha 2 falhou!")

header = getHeader("error_3_data.22o", logger)
obsTypes = getObsTypes(header, logger)
if obsTypes:
  print("Teste de falha 3 falhou!")

header = getHeader("error_4_data.22o", logger)
obsTypes = getObsTypes(header, logger)
if obsTypes:
  print("Teste de falha 4 falhou!")

header = getHeader("error_5_data.22o", logger)
obsTypes = getObsTypes(header, logger)
if obsTypes:
  print("Teste de falha 5 falhou!")

header = getHeader("não_existe.nan", logger)
if header:
  print("Teste de falha 6 falhou!")

header = getHeader("other_data.pnm", logger)
if header:
  print("Teste de falha 7 falhou!")

header = getHeader("v2_data.22o", logger)
if header:
  print("Teste de falha 8 falhou!")

header = getHeader("nav_data.22o", logger)
if header:
  print("Teste de falha 9 falhou!")

logger.close()

"""#### Rotinas para recuperar registros de dados (épocas)"""

# Teste de leitura e contagem das épocas
header = getHeader("slice_of_data.23o")
with open("slice_of_data.23o") as file:
  epocas = [getNextEpoach(file, len(header))]
  while True:
    epoca = getNextEpoach(file)
    if epoca is None:
      break
    else:
      epocas.append(epoca)
  print(len(epocas))

!sed 's/> 2023 11 17 12 45 40/_ 2023 11 17 12 45 40/g' slice_of_data.23o > error_6_data.23o

# Teste de tolerância à falhas ao recuperar épocas
logfile = open("erro_ao_ler_épocas.log","w")
filename = "error_6_data.23o"
header = getHeader(filename, log = logfile)
with open(filename) as file:
  epocas = [getNextEpoach(file, len(header), log = logfile)]
  while True:
    epoca = getNextEpoach(file, log = logfile)
    if epoca is None:
      break
    else:
      epocas.append(epoca)

if len(epocas) != 3:
  print("Teste falhou!")
logfile.close()

!sed 's/29/2A/g' slice_of_data.23o > error_7_data.23o

# Teste de tolerância à falhas ao recuperar épocas
logfile = open("erro_ao_ler_épocas.log","a")
filename = "error_7_data.23o"
header = getHeader(filename, log = logfile)
with open(filename) as file:
  epocas = [getNextEpoach(file, len(header), log = logfile)]
  while True:
    epoca = getNextEpoach(file, log = logfile)
    if epoca is None:
      break
    else:
      epocas.append(epoca)

if len(epocas) != 1:
  print("Teste falhou!")
logfile.close()

!sed 's/30/31/g' slice_of_data.23o > error_8_data.23o

# Teste de tolerância à falhas ao recuperar épocas
logfile = open("erro_ao_ler_épocas.log","a")
filename = "error_8_data.23o"
header = getHeader(filename, log = logfile)
with open(filename) as file:
  epocas = [getNextEpoach(file, len(header), log = logfile)]
  while True:
    epoca = getNextEpoach(file, log = logfile)
    if epoca is None:
      break
    else:
      epocas.append(epoca)

if len(epocas) != 3:
  print("Teste falhou!")
logfile.close()

!sed 's/C12/B12/g' slice_of_data.23o > error_9_data.23o

# Teste de tolerância à falhas ao recuperar épocas
logfile = open("erro_ao_ler_épocas.log","a")
filename = "error_9_data.23o"
header = getHeader(filename, log = logfile)
with open(filename) as file:
  epocas = [getNextEpoach(file, len(header), log = logfile)]
  while True:
    epoca = getNextEpoach(file, log = logfile)
    if epoca is None:
      break
    else:
      epocas.append(epoca)

if len(epocas) != 1:
  print("Teste falhou!")
logfile.close()

"""#### Rotinas para indexação de variáveis por código"""

# Verificando a capacidade de indexar variáveis de arquivo por código
header = getHeader("slice_of_data.23o")
obsTypes = getObsTypes(header)
codes = mapObsCodes(obsTypes)

for code in codes:
  print(code)
  for var in codes[code]:
    print(" "+var)
    for index in codes[code][var]:
      print("   "+index, codes[code][var][index])

!sed 's/S2I/T2I/g' slice_of_data.23o > error_10_data.23o

# Teste de tolerância à falhas ao indexar variáveis
logfile = open("erro_ao_indexar_variáveis.log","w")
filename = "error_10_data.23o"
header = getHeader(filename,logfile)
obsTypes = getObsTypes(header,logfile)
codes = mapObsCodes(obsTypes,logfile)
logfile.close()

if codes:
  print("Teste falhou!")

!sed 's/D2I/D2Z/g' slice_of_data.23o > error_11_data.23o

# Teste de tolerância à falhas ao indexar variáveis
logfile = open("erro_ao_indexar_variáveis.log","a")
filename = "error_11_data.23o"
header = getHeader(filename,logfile)
obsTypes = getObsTypes(header,logfile)
codes = mapObsCodes(obsTypes,logfile)
logfile.close()

if codes:
  print("Teste falhou!")

!sed 's/D2I/D2 /g' slice_of_data.23o > error_12_data.23o

# Teste de tolerância à falhas ao indexar variáveis
logfile = open("erro_ao_indexar_variáveis.log","a")
filename = "error_12_data.23o"
header = getHeader(filename,logfile)
obsTypes = getObsTypes(header,logfile)
codes = mapObsCodes(obsTypes,logfile)
logfile.close()

if codes:
  print("Teste falhou!")

!sed 's/E   12/B   12/g' slice_of_data.23o > error_13_data.23o

# Teste de tolerância à falhas ao indexar variáveis
logfile = open("erro_ao_indexar_variáveis.log","a")
filename = "error_13_data.23o"
header = getHeader(filename,logfile)
obsTypes = getObsTypes(header,logfile)
codes = mapObsCodes(obsTypes,logfile)
logfile.close()

if codes:
  print("Teste falhou!")

"""#### Rotinas para determinar e alterar tempo"""

# Teste de recuperação da primeira época no cabeçalho
header = getHeader("slice_of_data.23o")
print(getInitialTime(header))

# Teste de leitura do tempo das épocas
header = getHeader("slice_of_data.23o")
with open("slice_of_data.23o") as file:
  epoca = getNextEpoach(file, len(header))
  print(getEpoachTime(epoca))
  while True:
    epoca = getNextEpoach(file)
    if epoca is None:
      break
    else:
      print(getEpoachTime(epoca))

# Teste da medida de tempo entre as épocas
header = getHeader("slice_of_data.23o")
with open("slice_of_data.23o") as file:
  epoca0 = getNextEpoach(file, len(header))
  while True:
    epoca1 = getNextEpoach(file)
    if epoca1 is None:
      break
    else:
      print(getEpoachDelta(epoca0, epoca1))
      epoca0 = epoca1

# Teste de alteração da primeira época no cabeçalho
header = getHeader("slice_of_data.23o")
#print(header[20])
header = setInitialTime(header,datetime.now())
#print(header[20])
for line in header:
  print(line,end="")

# Teste de alteração do tempo das épocas
header = getHeader("slice_of_data.23o")
d = datetime.now()
t = timedelta(seconds = 1)
with open("slice_of_data.23o") as file:
  epoca = getNextEpoach(file, len(header))
  i = 0
  while True:
    epoca = setEpoachTime(epoca,d+t*i)
    i += 1
    for line in epoca:
      print(line,end="")
    epoca = getNextEpoach(file)
    if epoca is None:
      break

!sed 's/38.4408343     GPS/38.440834300000GPS/g' slice_of_data.23o > error_14_data.23o

# Teste de tolerância à falhas ao indexar variáveis
logfile = open("erro_ao_manipular_tempo.log","w")
filename = "error_14_data.23o"

header = getHeader(filename,logfile)
d = getInitialTime(header,logfile)
if d:
  print("Teste de leitura de tempo inicial falhou!")

header = setInitialTime(header,datetime.now(),logfile)
if header:
  print("Teste de escrita de tempo inicial falhou!")

logfile.close()

!sed 's/38.4408343  3  1/38.AA08343  3  1  1/g;' slice_of_data.23o > error_15_data.23o

# Teste de tolerância à falhas ao indexar variáveis
logfile = open("erro_ao_manipular_tempo.log","a")
filename = "error_15_data.23o"

header = getHeader(filename,logfile)
d = datetime.now()
t = timedelta(seconds = 1)
with open(filename) as file:
  epoca = getNextEpoach(file, len(header),log=logfile)
  i = 0
  T = getEpoachTime(epoca,logfile)
  if T:
    print("Teste de leitura de tempo em época falhou!")
  epoca = setEpoachTime(epoca,d+t*i,logfile)
  if epoca:
    print("Teste de escrita de tempo em época falhou!")

logfile.close()

"""#### Rotinas para recuperar e alterar dados"""

# Teste de leitura dos dados em uma época
header = getHeader("slice_of_data.23o")
obsTypes = getObsTypes(header)
codes = mapObsCodes(obsTypes)
with open("slice_of_data.23o") as file:
  getNextEpoach(file, len(header))
  epoca = getNextEpoach(file)
  print("PRN VAR             SOURCE          VALUE LLI SSI")
  for register in epoca[1:]:
    for var in obsTypes[register[0]]:
      d = [repr(i) if type(i) == str else i for i in tuple(getObsData(register,var,codes).values())]
      print(register[:3], var, "%18s %14.3f %3s %2s" % tuple(d) )

# Teste de alteracão dos dados em uma época
import random
header = getHeader("slice_of_data.23o")
obsTypes = getObsTypes(header)
codes = mapObsCodes(obsTypes)
with open("slice_of_data.23o") as file:
  getNextEpoach(file, len(header))
  epoca = getNextEpoach(file)
  for register in epoca[1:]:
    print(repr(register))
    vars = list(obsTypes[register[0]])
    random.shuffle(vars)
    for var in vars:
      register = setObsData(register,10000000,'1','0',var,codes)
      print(repr(register))
    print()

"""#### Rotinas para memorizar observacões"""

# Teste de persistência e acesso à memória de observacões
header = getHeader("slice_of_data.23o")
obsTypes = getObsTypes(header)
codes = mapObsCodes(obsTypes)
memory = {}
with open("slice_of_data.23o") as file:
  getNextEpoach(file, len(header))
  epoca = getNextEpoach(file)
  dt = getEpoachTime(epoca)
  for register in epoca[1:]:
    vars = list(obsTypes[register[0]])
    random.shuffle(vars)
    for var in vars:
      data = getObsData(register,var,codes)
      updateObsRegisterMemory(register[:3], var, data, dt, memory)

for x in memory:
  print(x, memory[x]['datetime'])
  for y in memory[x]['type']:
    for z in memory[x]['type'][y]:
      print("   ", z+y, memory[x]['type'][y][z])

# Teste do intervalos de tempo entre duas observações de um mesmo satélite
header = getHeader("slice_of_data.23o")
obsTypes = getObsTypes(header)
codes = mapObsCodes(obsTypes)
memory = {}
with open("slice_of_data.23o") as file:
  getNextEpoach(file, len(header))
  epoca = getNextEpoach(file)
  while epoca:
    print(epoca[0],end="")
    dt = getEpoachTime(epoca)
    for register in epoca[1:]:
      vars = list(obsTypes[register[0]])
      random.shuffle(vars)
      print(register[:3], getObsRegisterDelta(register, dt, memory))
      for var in vars:
        data = getObsData(register,var,codes)
        updateObsRegisterMemory(register[:3], var, data, dt, memory)
    epoca = getNextEpoach(file)

"""#### Rotina que implementa o pipeline dos alunos aluno Matheus Belo e Lucas"""

matheus('slice_of_data.23o', output_prefix="mat_")

# Teste de leitura dos dados gravados
header = getHeader("mat_slice_of_data.23o")
obsTypes = getObsTypes(header)
codes = mapObsCodes(obsTypes)
with open("mat_slice_of_data.23o") as file:
  getNextEpoach(file, len(header))
  epoca = getNextEpoach(file)
  epoca = getNextEpoach(file)
  print(epoca[0])
  print("PRN VAR             SOURCE          VALUE LLI SSI")
  for register in epoca[1:]:
    for var in obsTypes[register[0]]:
      d = [repr(i) if type(i) == str else i for i in tuple(getObsData(register,var,codes).values())]
      print(register[:3], var, "%18s %14.3f %3s %2s" % tuple(d) )
  epoca = getNextEpoach(file)
  print(epoca[0])
  print("PRN VAR             SOURCE          VALUE LLI SSI")
  for register in epoca[1:]:
    for var in obsTypes[register[0]]:
      d = [repr(i) if type(i) == str else i for i in tuple(getObsData(register,var,codes).values())]
      print(register[:3], var, "%18s %14.3f %3s %2s" % tuple(d) )

lucas('slice_of_data.23o', output_prefix="luc_")

# Teste de leitura dos dados gravados
header = getHeader("luc_slice_of_data.23o")
obsTypes = getObsTypes(header)
codes = mapObsCodes(obsTypes)
with open("luc_slice_of_data.23o") as file:
  getNextEpoach(file, len(header))
  epoca = getNextEpoach(file)
  print(epoca[0])
  print("PRN VAR             SOURCE          VALUE LLI SSI")
  for register in epoca[1:]:
    for var in obsTypes[register[0]]:
      d = [repr(i) if type(i) == str else i for i in tuple(getObsData(register,var,codes).values())]
      print(register[:3], var, "%18s %14.3f %3s %2s" % tuple(d) )
  epoca = getNextEpoach(file)
  print(epoca[0])
  print("PRN VAR             SOURCE          VALUE LLI SSI")
  for register in epoca[1:]:
    for var in obsTypes[register[0]]:
      d = [repr(i) if type(i) == str else i for i in tuple(getObsData(register,var,codes).values())]
      print(register[:3], var, "%18s %14.3f %3s %2s" % tuple(d) )

"""Fim de testes"""

import os
os.chdir('/content/')

"""## Seção reservada para uso do módulo"""

import RinexRemake as rr
filename = "GEOP321M (header editado).23o"
rr.lucas(filename)